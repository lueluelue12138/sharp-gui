import{D as ut,Q as ge,B as Xs,M as pt,V as v,a as N,S as An,P as gn,O as Js,W as Cn,C as Et,b as J,c as Zs,d as qt,e as De,f as nt,g as Ue,R as Mt,U as ot,h as Bt,F as fs,i as Sn,H as yn,j as xn,k as In,l as Tn,m as Bn,n as En,o as it,p as ms,q as As,r as wn,s as gs,t as vn,u as Xe,v as Cs,w as Wt,x as Fn,y as Ss,E as Dn,z as Ge,T as qe,A as ys,G as bn,I as Rn,J as Mn,K as Pn,L as On,N as Ln,X as $s,Y as xs,Z as Qe}from"./three-Bs5sq_-A.js";class _e{static idGen=0;constructor(e,s){let t,n;this.promise=new Promise((l,c)=>{t=l,n=c});const o=t.bind(this),i=n.bind(this),r=(...l)=>{o(...l)},a=l=>{i(l)};e(r.bind(this),a.bind(this)),this.abortHandler=s,this.id=_e.idGen++}then(e){return new _e((s,t)=>{this.promise=this.promise.then((...n)=>{const o=e(...n);o instanceof Promise||o instanceof _e?o.then((...i)=>{s(...i)}):s(o)}).catch(n=>{t(n)})},this.abortHandler)}catch(e){return new _e(s=>{this.promise=this.promise.then((...t)=>{s(...t)}).catch(e)},this.abortHandler)}abort(e){this.abortHandler&&this.abortHandler(e)}}class en extends Error{constructor(e){super(e)}}(function(){const m=new Float32Array(1),e=new Int32Array(m.buffer);return function(s){m[0]=s;const t=e[0];let n=t>>16&32768,o=t>>12&2047;const i=t>>23&255;return i<103?n:i>142?(n|=31744,n|=(i==255?0:1)&&t&8388607,n):i<113?(o|=2048,n|=(o>>114-i)+(o>>113-i&1),n):(n|=i-112<<10|o>>1,n+=o&1,n)}})();const Pt=(function(){const m=new Float32Array(1),e=new Int32Array(m.buffer);return function(s){return m[0]=s,e[0]}})(),kn=function(m,e){return m[e]+(m[e+1]<<8)+(m[e+2]<<16)+(m[e+3]<<24)},Dt=function(m,e,s=!0,t){const n=new AbortController,o=n.signal;let i=!1;const r=c=>{n.abort(c),i=!0};let a=!1;const l=(c,d,u,h)=>{e&&!a&&(e(c,d,u,h),c===100&&(a=!0))};return new _e((c,d)=>{const u={signal:o};t&&(u.headers=t),fetch(m,u).then(async h=>{if(!h.ok){const x=await h.text();d(new Error(`Fetch failed: ${h.status} ${h.statusText} ${x}`));return}const f=h.body.getReader();let p=0,A=h.headers.get("Content-Length"),C=A?parseInt(A):void 0;const g=[];for(;!i;)try{const{value:x,done:B}=await f.read();if(B){if(l(100,"100%",x,C),s){const S=new Blob(g).arrayBuffer();c(S)}else c();break}p+=x.length;let y,E;C!==void 0&&(y=p/C*100,E=`${y.toFixed(2)}%`),s&&g.push(x),l(y,E,x,C)}catch(x){d(x);return}}).catch(h=>{d(new en(h))})},r)},re=function(m,e,s){return Math.max(Math.min(m,s),e)},We=function(){return performance.now()/1e3},Ye=m=>{if(m.geometry&&(m.geometry.dispose(),m.geometry=null),m.material&&(m.material.dispose(),m.material=null),m.children)for(let e of m.children)Ye(e)},ve=(m,e)=>new Promise(s=>{window.setTimeout(()=>{s(m?m():void 0)},e?1:50)}),Je=(m=0)=>{let e=0;if(m===1)e=9;else if(m===2)e=24;else if(m===3)e=45;else if(m>3)throw new Error("getSphericalHarmonicsComponentCountForDegree() -> Invalid spherical harmonics degree");return e},Kt=()=>{let m,e;return{promise:new Promise((t,n)=>{m=t,e=n}),resolve:m,reject:e}},Ot=m=>{let e,s;return m||(m=()=>{}),{promise:new _e((n,o)=>{e=n,s=o},m),resolve:e,reject:s}};class Hn{constructor(e,s,t){this.major=e,this.minor=s,this.patch=t}toString(){return`${this.major}_${this.minor}_${this.patch}`}}function jt(){const m=navigator.userAgent;return m.indexOf("iPhone")>0||m.indexOf("iPad")>0}function tn(){if(jt()){const m=navigator.userAgent.match(/OS (\d+)_(\d+)_?(\d+)?/);return new Hn(parseInt(m[1]||0,10),parseInt(m[2]||0,10),parseInt(m[3]||0,10))}else return null}const Un=14;class P{static OFFSET={X:0,Y:1,Z:2,SCALE0:3,SCALE1:4,SCALE2:5,ROTATION0:6,ROTATION1:7,ROTATION2:8,ROTATION3:9,FDC0:10,FDC1:11,FDC2:12,OPACITY:13,FRC0:14,FRC1:15,FRC2:16,FRC3:17,FRC4:18,FRC5:19,FRC6:20,FRC7:21,FRC8:22,FRC9:23,FRC10:24,FRC11:25,FRC12:26,FRC13:27,FRC14:28,FRC15:29,FRC16:30,FRC17:31,FRC18:32,FRC19:33,FRC20:34,FRC21:35,FRC22:36,FRC23:37};constructor(e=0){this.sphericalHarmonicsDegree=e,this.sphericalHarmonicsCount=Je(this.sphericalHarmonicsDegree),this.componentCount=this.sphericalHarmonicsCount+Un,this.defaultSphericalHarmonics=new Array(this.sphericalHarmonicsCount).fill(0),this.splats=[],this.splatCount=0}static createSplat(e=0){const s=[0,0,0,1,1,1,1,0,0,0,0,0,0,0];let t=Je(e);for(let n=0;n<t;n++)s.push(0);return s}addSplat(e){this.splats.push(e),this.splatCount++}getSplat(e){return this.splats[e]}addDefaultSplat(){const e=P.createSplat(this.sphericalHarmonicsDegree);return this.addSplat(e),e}addSplatFromComonents(e,s,t,n,o,i,r,a,l,c,d,u,h,f,...p){const A=[e,s,t,n,o,i,r,a,l,c,d,u,h,f,...this.defaultSphericalHarmonics];for(let C=0;C<p.length&&C<this.sphericalHarmonicsCount;C++)A[C]=p[C];return this.addSplat(A),A}addSplatFromArray(e,s){const t=e.splats[s],n=P.createSplat(this.sphericalHarmonicsDegree);for(let o=0;o<this.componentCount&&o<t.length;o++)n[o]=t[o];this.addSplat(n)}}class Y{static DefaultSplatSortDistanceMapPrecision=16;static MemoryPageSize=65536;static BytesPerFloat=4;static BytesPerInt=4;static MaxScenes=32;static ProgressiveLoadSectionSize=262144;static ProgressiveLoadSectionDelayDuration=15;static SphericalHarmonics8BitCompressionRange=3}const zn=Y.SphericalHarmonics8BitCompressionRange,ze=zn/2,Ae=ut.toHalfFloat.bind(ut),Yt=ut.fromHalfFloat.bind(ut),oe=(m,e,s=!1,t,n)=>{if(e===0)return m;if(e===1||e===2&&!s)return ut.fromHalfFloat(m);if(e===2)return Xt(m,t,n)},at=(m,e,s)=>{m=re(m,e,s);const t=s-e;return re(Math.floor((m-e)/t*255),0,255)},Xt=(m,e,s)=>{const t=s-e;return m/255*t+e},sn=(m,e,s)=>at(Yt(m,e,s)),_n=(m,e,s)=>Ae(Xt(m,e,s)),K=(m,e,s,t=!1)=>s===0?m.getFloat32(e*4,!0):s===1||s===2&&!t?m.getUint16(e*2,!0):m.getUint8(e,!0),Qn=(function(){const m=e=>e;return function(e,s,t,n=!1){if(s===t)return e;let o=m;return s===2&&n?t===1?o=_n:t==0&&(o=Xt):s===2||s===1?t===0?o=Yt:t==2&&(n?o=sn:o=m):s===0&&(t===1?o=Ae:t==2&&(n?o=at:o=Ae)),o(e)}})(),Ke=(m,e,s,t,n=0)=>{const o=new Uint8Array(m,e),i=new Uint8Array(s,t);for(let r=0;r<n;r++)i[r]=o[r]};class I{static CurrentMajorVersion=0;static CurrentMinorVersion=1;static CenterComponentCount=3;static ScaleComponentCount=3;static RotationComponentCount=4;static ColorComponentCount=4;static CovarianceComponentCount=6;static SplatScaleOffsetFloat=3;static SplatRotationOffsetFloat=6;static CompressionLevels={0:{BytesPerCenter:12,BytesPerScale:12,BytesPerRotation:16,BytesPerColor:4,ScaleOffsetBytes:12,RotationffsetBytes:24,ColorOffsetBytes:40,SphericalHarmonicsOffsetBytes:44,ScaleRange:1,BytesPerSphericalHarmonicsComponent:4,SphericalHarmonicsOffsetFloat:11,SphericalHarmonicsDegrees:{0:{BytesPerSplat:44},1:{BytesPerSplat:80},2:{BytesPerSplat:140}}},1:{BytesPerCenter:6,BytesPerScale:6,BytesPerRotation:8,BytesPerColor:4,ScaleOffsetBytes:6,RotationffsetBytes:12,ColorOffsetBytes:20,SphericalHarmonicsOffsetBytes:24,ScaleRange:32767,BytesPerSphericalHarmonicsComponent:2,SphericalHarmonicsOffsetFloat:12,SphericalHarmonicsDegrees:{0:{BytesPerSplat:24},1:{BytesPerSplat:42},2:{BytesPerSplat:72}}},2:{BytesPerCenter:6,BytesPerScale:6,BytesPerRotation:8,BytesPerColor:4,ScaleOffsetBytes:6,RotationffsetBytes:12,ColorOffsetBytes:20,SphericalHarmonicsOffsetBytes:24,ScaleRange:32767,BytesPerSphericalHarmonicsComponent:1,SphericalHarmonicsOffsetFloat:12,SphericalHarmonicsDegrees:{0:{BytesPerSplat:24},1:{BytesPerSplat:33},2:{BytesPerSplat:48}}}};static CovarianceSizeFloats=6;static HeaderSizeBytes=4096;static SectionHeaderSizeBytes=1024;static BucketStorageSizeBytes=12;static BucketStorageSizeFloats=3;static BucketBlockSize=5;static BucketSize=256;constructor(e,s=!0){this.constructFromBuffer(e,s)}getSplatCount(){return this.splatCount}getMaxSplatCount(){return this.maxSplatCount}getMinSphericalHarmonicsDegree(){let e=0;for(let s=0;s<this.sections.length;s++){const t=this.sections[s];(s===0||t.sphericalHarmonicsDegree<e)&&(e=t.sphericalHarmonicsDegree)}return e}getBucketIndex(e,s){let t;const n=e.fullBucketCount*e.bucketSize;if(s<n)t=Math.floor(s/e.bucketSize);else{let o=n;t=e.fullBucketCount;let i=0;for(;o<e.splatCount;){let r=e.partiallyFilledBucketLengths[i];if(s>=o&&s<o+r)break;o+=r,t++,i++}}return t}getSplatCenter(e,s,t){const n=this.globalSplatIndexToSectionMap[e],o=this.sections[n],i=e-o.splatCountOffset,r=o.bytesPerSplat*i,a=new DataView(this.bufferData,o.dataBase+r),l=K(a,0,this.compressionLevel),c=K(a,1,this.compressionLevel),d=K(a,2,this.compressionLevel);if(this.compressionLevel>=1){const h=this.getBucketIndex(o,i)*I.BucketStorageSizeFloats,f=o.compressionScaleFactor,p=o.compressionScaleRange;s.x=(l-p)*f+o.bucketArray[h],s.y=(c-p)*f+o.bucketArray[h+1],s.z=(d-p)*f+o.bucketArray[h+2]}else s.x=l,s.y=c,s.z=d;t&&s.applyMatrix4(t)}getSplatScaleAndRotation=(function(){const e=new J,s=new J,t=new J,n=new v,o=new v,i=new ge;return function(r,a,l,c,d){const u=this.globalSplatIndexToSectionMap[r],h=this.sections[u],f=r-h.splatCountOffset,p=h.bytesPerSplat*f+I.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,A=new DataView(this.bufferData,h.dataBase+p);o.set(oe(K(A,0,this.compressionLevel),this.compressionLevel),oe(K(A,1,this.compressionLevel),this.compressionLevel),oe(K(A,2,this.compressionLevel),this.compressionLevel)),d&&(d.x!==void 0&&(o.x=d.x),d.y!==void 0&&(o.y=d.y),d.z!==void 0&&(o.z=d.z)),i.set(oe(K(A,4,this.compressionLevel),this.compressionLevel),oe(K(A,5,this.compressionLevel),this.compressionLevel),oe(K(A,6,this.compressionLevel),this.compressionLevel),oe(K(A,3,this.compressionLevel),this.compressionLevel)),c?(e.makeScale(o.x,o.y,o.z),s.makeRotationFromQuaternion(i),t.copy(e).multiply(s).multiply(c),t.decompose(n,l,a)):(a.copy(o),l.copy(i))}})();getSplatColor(e,s){const t=this.globalSplatIndexToSectionMap[e],n=this.sections[t],o=e-n.splatCountOffset,i=n.bytesPerSplat*o+I.CompressionLevels[this.compressionLevel].ColorOffsetBytes,r=new Uint8Array(this.bufferData,n.dataBase+i,4);s.set(r[0],r[1],r[2],r[3])}fillSplatCenterArray(e,s,t,n,o){const i=this.splatCount;t=t||0,n=n||i-1,o===void 0&&(o=t);const r=new v;for(let a=t;a<=n;a++){const l=this.globalSplatIndexToSectionMap[a],c=this.sections[l],d=a-c.splatCountOffset,u=(a-t+o)*I.CenterComponentCount,h=c.bytesPerSplat*d,f=new DataView(this.bufferData,c.dataBase+h),p=K(f,0,this.compressionLevel),A=K(f,1,this.compressionLevel),C=K(f,2,this.compressionLevel);if(this.compressionLevel>=1){const x=this.getBucketIndex(c,d)*I.BucketStorageSizeFloats,B=c.compressionScaleFactor,y=c.compressionScaleRange;r.x=(p-y)*B+c.bucketArray[x],r.y=(A-y)*B+c.bucketArray[x+1],r.z=(C-y)*B+c.bucketArray[x+2]}else r.x=p,r.y=A,r.z=C;s&&r.applyMatrix4(s),e[u]=r.x,e[u+1]=r.y,e[u+2]=r.z}}fillSplatScaleRotationArray=(function(){const e=new J,s=new J,t=new J,n=new v,o=new ge,i=new v,r=a=>{const l=a.w<0?-1:1;a.x*=l,a.y*=l,a.z*=l,a.w*=l};return function(a,l,c,d,u,h,f,p){const A=this.splatCount;d=d||0,u=u||A-1,h===void 0&&(h=d);const C=(g,x)=>Qn(g,x,f);for(let g=d;g<=u;g++){const x=this.globalSplatIndexToSectionMap[g],B=this.sections[x],y=g-B.splatCountOffset,E=B.bytesPerSplat*y+I.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,S=(g-d+h)*I.ScaleComponentCount,w=(g-d+h)*I.RotationComponentCount,F=new DataView(this.bufferData,B.dataBase+E),b=p&&p.x!==void 0?p.x:K(F,0,this.compressionLevel),D=p&&p.y!==void 0?p.y:K(F,1,this.compressionLevel),M=p&&p.z!==void 0?p.z:K(F,2,this.compressionLevel),L=K(F,3,this.compressionLevel),R=K(F,4,this.compressionLevel),O=K(F,5,this.compressionLevel),k=K(F,6,this.compressionLevel);n.set(oe(b,this.compressionLevel),oe(D,this.compressionLevel),oe(M,this.compressionLevel)),o.set(oe(R,this.compressionLevel),oe(O,this.compressionLevel),oe(k,this.compressionLevel),oe(L,this.compressionLevel)).normalize(),c&&(i.set(0,0,0),e.makeScale(n.x,n.y,n.z),s.makeRotationFromQuaternion(o),t.identity().premultiply(e).premultiply(s),t.premultiply(c),t.decompose(i,o,n),o.normalize()),r(o),a&&(a[S]=C(n.x,0),a[S+1]=C(n.y,0),a[S+2]=C(n.z,0)),l&&(l[w]=C(o.x,0),l[w+1]=C(o.y,0),l[w+2]=C(o.z,0),l[w+3]=C(o.w,0))}}})();static computeCovariance=(function(){const e=new J,s=new Qe,t=new Qe,n=new Qe,o=new Qe,i=new Qe,r=new Qe;return function(a,l,c,d,u=0,h){e.makeScale(a.x,a.y,a.z),s.setFromMatrix4(e),e.makeRotationFromQuaternion(l),t.setFromMatrix4(e),n.copy(t).multiply(s),o.copy(n).transpose().premultiply(n),c&&(i.setFromMatrix4(c),r.copy(i).transpose(),o.multiply(r),o.premultiply(i)),h>=1?(d[u]=Ae(o.elements[0]),d[u+1]=Ae(o.elements[3]),d[u+2]=Ae(o.elements[6]),d[u+3]=Ae(o.elements[4]),d[u+4]=Ae(o.elements[7]),d[u+5]=Ae(o.elements[8])):(d[u]=o.elements[0],d[u+1]=o.elements[3],d[u+2]=o.elements[6],d[u+3]=o.elements[4],d[u+4]=o.elements[7],d[u+5]=o.elements[8])}})();fillSplatCovarianceArray(e,s,t,n,o,i){const r=this.splatCount,a=new v,l=new ge;t=t||0,n=n||r-1,o===void 0&&(o=t);for(let c=t;c<=n;c++){const d=this.globalSplatIndexToSectionMap[c],u=this.sections[d],h=c-u.splatCountOffset,f=(c-t+o)*I.CovarianceComponentCount,p=u.bytesPerSplat*h+I.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,A=new DataView(this.bufferData,u.dataBase+p);a.set(oe(K(A,0,this.compressionLevel),this.compressionLevel),oe(K(A,1,this.compressionLevel),this.compressionLevel),oe(K(A,2,this.compressionLevel),this.compressionLevel)),l.set(oe(K(A,4,this.compressionLevel),this.compressionLevel),oe(K(A,5,this.compressionLevel),this.compressionLevel),oe(K(A,6,this.compressionLevel),this.compressionLevel),oe(K(A,3,this.compressionLevel),this.compressionLevel)),I.computeCovariance(a,l,s,e,f,i)}}fillSplatColorArray(e,s,t,n,o){const i=this.splatCount;t=t||0,n=n||i-1,o===void 0&&(o=t);for(let r=t;r<=n;r++){const a=this.globalSplatIndexToSectionMap[r],l=this.sections[a],c=r-l.splatCountOffset,d=(r-t+o)*I.ColorComponentCount,u=l.bytesPerSplat*c+I.CompressionLevels[this.compressionLevel].ColorOffsetBytes,h=new Uint8Array(this.bufferData,l.dataBase+u);let f=h[3];f=f>=s?f:0,e[d]=h[0],e[d+1]=h[1],e[d+2]=h[2],e[d+3]=f}}fillSphericalHarmonicsArray=(function(){for(let R=0;R<15;R++)new v;const e=new Qe,s=new J,t=new v,n=new v,o=new ge,i=[],r=[],a=[],l=[],c=[],d=[],u=[],h=[],f=[],p=[],A=[],C=[],g=[],x=[],B=[],y=[],E=[],S=[],w=R=>R,F=(R,O,k,U)=>{R[0]=O,R[1]=k,R[2]=U},b=(R,O,k,U,_)=>{R[0]=K(O,U,_,!0),R[1]=K(O,U+k,_,!0),R[2]=K(O,U+k+k,_,!0)},D=(R,O)=>{O[0]=R[0],O[1]=R[1],O[2]=R[2]},M=(R,O,k,U)=>{O[k]=U(R[0]),O[k+1]=U(R[1]),O[k+2]=U(R[2])},L=(R,O,k,U,_)=>(O[0]=oe(R[0],k,!0,U,_),O[1]=oe(R[1],k,!0,U,_),O[2]=oe(R[2],k,!0,U,_),O);return function(R,O,k,U,_,H,Q){const ee=this.splatCount;U=U||0,_=_||ee-1,H===void 0&&(H=U),k&&O>=1&&(s.copy(k),s.decompose(t,o,n),o.normalize(),s.makeRotationFromQuaternion(o),e.setFromMatrix4(s),F(i,e.elements[4],-e.elements[7],e.elements[1]),F(r,-e.elements[5],e.elements[8],-e.elements[2]),F(a,e.elements[3],-e.elements[6],e.elements[0]));const le=se=>sn(se,this.minSphericalHarmonicsCoeff,this.maxSphericalHarmonicsCoeff),V=se=>at(se,this.minSphericalHarmonicsCoeff,this.maxSphericalHarmonicsCoeff);for(let se=U;se<=_;se++){const Z=this.globalSplatIndexToSectionMap[se],G=this.sections[Z];O=Math.min(O,G.sphericalHarmonicsDegree);const X=Je(O),ce=se-G.splatCountOffset,de=G.bytesPerSplat*ce+I.CompressionLevels[this.compressionLevel].SphericalHarmonicsOffsetBytes,ie=new DataView(this.bufferData,G.dataBase+de),Se=(se-U+H)*X;let pe=k?0:this.compressionLevel,ne=w;pe!==Q&&(pe===1?Q===0?ne=Yt:Q==2&&(ne=le):pe===0&&(Q===1?ne=Ae:Q==2&&(ne=V)));const fe=this.minSphericalHarmonicsCoeff,$=this.maxSphericalHarmonicsCoeff;O>=1&&(b(f,ie,3,0,this.compressionLevel),b(p,ie,3,1,this.compressionLevel),b(A,ie,3,2,this.compressionLevel),k?(L(f,f,this.compressionLevel,fe,$),L(p,p,this.compressionLevel,fe,$),L(A,A,this.compressionLevel,fe,$),I.rotateSphericalHarmonics3(f,p,A,i,r,a,x,B,y)):(D(f,x),D(p,B),D(A,y)),M(x,R,Se,ne),M(B,R,Se+3,ne),M(y,R,Se+6,ne),O>=2&&(b(f,ie,5,9,this.compressionLevel),b(p,ie,5,10,this.compressionLevel),b(A,ie,5,11,this.compressionLevel),b(C,ie,5,12,this.compressionLevel),b(g,ie,5,13,this.compressionLevel),k?(L(f,f,this.compressionLevel,fe,$),L(p,p,this.compressionLevel,fe,$),L(A,A,this.compressionLevel,fe,$),L(C,C,this.compressionLevel,fe,$),L(g,g,this.compressionLevel,fe,$),I.rotateSphericalHarmonics5(f,p,A,C,g,i,r,a,l,c,d,u,h,x,B,y,E,S)):(D(f,x),D(p,B),D(A,y),D(C,E),D(g,S)),M(x,R,Se+9,ne),M(B,R,Se+12,ne),M(y,R,Se+15,ne),M(E,R,Se+18,ne),M(S,R,Se+21,ne)))}}})();static dot3=(e,s,t,n,o)=>{o[0]=o[1]=o[2]=0;const i=n[0],r=n[1],a=n[2];I.addInto3(e[0]*i,e[1]*i,e[2]*i,o),I.addInto3(s[0]*r,s[1]*r,s[2]*r,o),I.addInto3(t[0]*a,t[1]*a,t[2]*a,o)};static addInto3=(e,s,t,n)=>{n[0]=n[0]+e,n[1]=n[1]+s,n[2]=n[2]+t};static dot5=(e,s,t,n,o,i,r)=>{r[0]=r[1]=r[2]=0;const a=i[0],l=i[1],c=i[2],d=i[3],u=i[4];I.addInto3(e[0]*a,e[1]*a,e[2]*a,r),I.addInto3(s[0]*l,s[1]*l,s[2]*l,r),I.addInto3(t[0]*c,t[1]*c,t[2]*c,r),I.addInto3(n[0]*d,n[1]*d,n[2]*d,r),I.addInto3(o[0]*u,o[1]*u,o[2]*u,r)};static rotateSphericalHarmonics3=(e,s,t,n,o,i,r,a,l)=>{I.dot3(e,s,t,n,r),I.dot3(e,s,t,o,a),I.dot3(e,s,t,i,l)};static rotateSphericalHarmonics5=(e,s,t,n,o,i,r,a,l,c,d,u,h,f,p,A,C,g)=>{const x=Math.sqrt(.25),B=Math.sqrt(3/4),y=Math.sqrt(1/3),E=Math.sqrt(4/3),S=Math.sqrt(1/12);l[0]=x*(a[2]*i[0]+a[0]*i[2]+(i[2]*a[0]+i[0]*a[2])),l[1]=a[1]*i[0]+i[1]*a[0],l[2]=B*(a[1]*i[1]+i[1]*a[1]),l[3]=a[1]*i[2]+i[1]*a[2],l[4]=x*(a[2]*i[2]-a[0]*i[0]+(i[2]*a[2]-i[0]*a[0])),I.dot5(e,s,t,n,o,l,f),c[0]=x*(r[2]*i[0]+r[0]*i[2]+(i[2]*r[0]+i[0]*r[2])),c[1]=r[1]*i[0]+i[1]*r[0],c[2]=B*(r[1]*i[1]+i[1]*r[1]),c[3]=r[1]*i[2]+i[1]*r[2],c[4]=x*(r[2]*i[2]-r[0]*i[0]+(i[2]*r[2]-i[0]*r[0])),I.dot5(e,s,t,n,o,c,p),d[0]=y*(r[2]*r[0]+r[0]*r[2])+-S*(a[2]*a[0]+a[0]*a[2]+(i[2]*i[0]+i[0]*i[2])),d[1]=E*r[1]*r[0]+-y*(a[1]*a[0]+i[1]*i[0]),d[2]=r[1]*r[1]+-x*(a[1]*a[1]+i[1]*i[1]),d[3]=E*r[1]*r[2]+-y*(a[1]*a[2]+i[1]*i[2]),d[4]=y*(r[2]*r[2]-r[0]*r[0])+-S*(a[2]*a[2]-a[0]*a[0]+(i[2]*i[2]-i[0]*i[0])),I.dot5(e,s,t,n,o,d,A),u[0]=x*(r[2]*a[0]+r[0]*a[2]+(a[2]*r[0]+a[0]*r[2])),u[1]=r[1]*a[0]+a[1]*r[0],u[2]=B*(r[1]*a[1]+a[1]*r[1]),u[3]=r[1]*a[2]+a[1]*r[2],u[4]=x*(r[2]*a[2]-r[0]*a[0]+(a[2]*r[2]-a[0]*r[0])),I.dot5(e,s,t,n,o,u,C),h[0]=x*(a[2]*a[0]+a[0]*a[2]-(i[2]*i[0]+i[0]*i[2])),h[1]=a[1]*a[0]-i[1]*i[0],h[2]=B*(a[1]*a[1]-i[1]*i[1]),h[3]=a[1]*a[2]-i[1]*i[2],h[4]=x*(a[2]*a[2]-a[0]*a[0]-(i[2]*i[2]-i[0]*i[0])),I.dot5(e,s,t,n,o,h,g)};static parseHeader(e){const s=new Uint8Array(e,0,I.HeaderSizeBytes),t=new Uint16Array(e,0,I.HeaderSizeBytes/2),n=new Uint32Array(e,0,I.HeaderSizeBytes/4),o=new Float32Array(e,0,I.HeaderSizeBytes/4),i=s[0],r=s[1],a=n[1],l=n[2],c=n[3],d=n[4],u=t[10],h=new v(o[6],o[7],o[8]),f=o[9]||-ze,p=o[10]||ze;return{versionMajor:i,versionMinor:r,maxSectionCount:a,sectionCount:l,maxSplatCount:c,splatCount:d,compressionLevel:u,sceneCenter:h,minSphericalHarmonicsCoeff:f,maxSphericalHarmonicsCoeff:p}}static writeHeaderCountsToBuffer(e,s,t){const n=new Uint32Array(t,0,I.HeaderSizeBytes/4);n[2]=e,n[4]=s}static writeHeaderToBuffer(e,s){const t=new Uint8Array(s,0,I.HeaderSizeBytes),n=new Uint16Array(s,0,I.HeaderSizeBytes/2),o=new Uint32Array(s,0,I.HeaderSizeBytes/4),i=new Float32Array(s,0,I.HeaderSizeBytes/4);t[0]=e.versionMajor,t[1]=e.versionMinor,t[2]=0,t[3]=0,o[1]=e.maxSectionCount,o[2]=e.sectionCount,o[3]=e.maxSplatCount,o[4]=e.splatCount,n[10]=e.compressionLevel,i[6]=e.sceneCenter.x,i[7]=e.sceneCenter.y,i[8]=e.sceneCenter.z,i[9]=e.minSphericalHarmonicsCoeff||-ze,i[10]=e.maxSphericalHarmonicsCoeff||ze}static parseSectionHeaders(e,s,t=0,n){const o=e.compressionLevel,i=e.maxSectionCount,r=new Uint16Array(s,t,i*I.SectionHeaderSizeBytes/2),a=new Uint32Array(s,t,i*I.SectionHeaderSizeBytes/4),l=new Float32Array(s,t,i*I.SectionHeaderSizeBytes/4),c=[];let d=0,u=d/2,h=d/4,f=I.HeaderSizeBytes+e.maxSectionCount*I.SectionHeaderSizeBytes,p=0;for(let A=0;A<i;A++){const C=a[h+1],g=a[h+2],x=a[h+3],B=l[h+4],y=B/2,E=r[u+10],S=a[h+6]||I.CompressionLevels[o].ScaleRange,w=a[h+8],F=a[h+9],b=F*4,D=E*x+b,M=r[u+20],{bytesPerSplat:L}=I.calculateComponentStorage(o,M),R=L*C,O=R+D,k={bytesPerSplat:L,splatCountOffset:p,splatCount:n?C:0,maxSplatCount:C,bucketSize:g,bucketCount:x,bucketBlockSize:B,halfBucketBlockSize:y,bucketStorageSizeBytes:E,bucketsStorageSizeBytes:D,splatDataStorageSizeBytes:R,storageSizeBytes:O,compressionScaleRange:S,compressionScaleFactor:y/S,base:f,bucketsBase:f+b,dataBase:f+D,fullBucketCount:w,partiallyFilledBucketCount:F,sphericalHarmonicsDegree:M};c[A]=k,f+=O,d+=I.SectionHeaderSizeBytes,u=d/2,h=d/4,p+=C}return c}static writeSectionHeaderToBuffer(e,s,t,n=0){const o=new Uint16Array(t,n,I.SectionHeaderSizeBytes/2),i=new Uint32Array(t,n,I.SectionHeaderSizeBytes/4),r=new Float32Array(t,n,I.SectionHeaderSizeBytes/4);i[0]=e.splatCount,i[1]=e.maxSplatCount,i[2]=s>=1?e.bucketSize:0,i[3]=s>=1?e.bucketCount:0,r[4]=s>=1?e.bucketBlockSize:0,o[10]=s>=1?I.BucketStorageSizeBytes:0,i[6]=s>=1?e.compressionScaleRange:0,i[7]=e.storageSizeBytes,i[8]=s>=1?e.fullBucketCount:0,i[9]=s>=1?e.partiallyFilledBucketCount:0,o[20]=e.sphericalHarmonicsDegree}static writeSectionHeaderSplatCountToBuffer(e,s,t=0){const n=new Uint32Array(s,t,I.SectionHeaderSizeBytes/4);n[0]=e}constructFromBuffer(e,s){this.bufferData=e,this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSectionMap=[];const t=I.parseHeader(this.bufferData);this.versionMajor=t.versionMajor,this.versionMinor=t.versionMinor,this.maxSectionCount=t.maxSectionCount,this.sectionCount=s?t.maxSectionCount:0,this.maxSplatCount=t.maxSplatCount,this.splatCount=s?t.maxSplatCount:0,this.compressionLevel=t.compressionLevel,this.sceneCenter=new v().copy(t.sceneCenter),this.minSphericalHarmonicsCoeff=t.minSphericalHarmonicsCoeff,this.maxSphericalHarmonicsCoeff=t.maxSphericalHarmonicsCoeff,this.sections=I.parseSectionHeaders(t,this.bufferData,I.HeaderSizeBytes,s),this.linkBufferArrays(),this.buildMaps()}static calculateComponentStorage(e,s){const t=I.CompressionLevels[e].BytesPerCenter,n=I.CompressionLevels[e].BytesPerScale,o=I.CompressionLevels[e].BytesPerRotation,i=I.CompressionLevels[e].BytesPerColor,r=Je(s),a=I.CompressionLevels[e].BytesPerSphericalHarmonicsComponent*r,l=t+n+o+i+a;return{bytesPerCenter:t,bytesPerScale:n,bytesPerRotation:o,bytesPerColor:i,sphericalHarmonicsComponentsPerSplat:r,sphericalHarmonicsBytesPerSplat:a,bytesPerSplat:l}}linkBufferArrays(){for(let e=0;e<this.maxSectionCount;e++){const s=this.sections[e];s.bucketArray=new Float32Array(this.bufferData,s.bucketsBase,s.bucketCount*I.BucketStorageSizeFloats),s.partiallyFilledBucketCount>0&&(s.partiallyFilledBucketLengths=new Uint32Array(this.bufferData,s.base,s.partiallyFilledBucketCount))}}buildMaps(){let e=0;for(let s=0;s<this.maxSectionCount;s++){const t=this.sections[s];for(let n=0;n<t.maxSplatCount;n++){const o=e+n;this.globalSplatIndexToLocalSplatIndexMap[o]=n,this.globalSplatIndexToSectionMap[o]=s}e+=t.maxSplatCount}}updateLoadedCounts(e,s){I.writeHeaderCountsToBuffer(e,s,this.bufferData),this.sectionCount=e,this.splatCount=s}updateSectionLoadedCounts(e,s){const t=I.HeaderSizeBytes+I.SectionHeaderSizeBytes*e;I.writeSectionHeaderSplatCountToBuffer(s,this.bufferData,t),this.sections[e].splatCount=s}static writeSplatDataToSectionBuffer=(function(){const e=new ArrayBuffer(12),s=new ArrayBuffer(12),t=new ArrayBuffer(16),n=new ArrayBuffer(4),o=new ArrayBuffer(256),i=new ge,r=new v,a=new v,{X:l,Y:c,Z:d,SCALE0:u,SCALE1:h,SCALE2:f,ROTATION0:p,ROTATION1:A,ROTATION2:C,ROTATION3:g,FDC0:x,FDC1:B,FDC2:y,OPACITY:E,FRC0:S,FRC9:w}=P.OFFSET,F=(b,D,M)=>{const L=M*2+1;return b=Math.round(b*D)+M,re(b,0,L)};return function(b,D,M,L,R,O,k,U,_=-ze,H=ze){const Q=Je(R),ee=I.CompressionLevels[L].BytesPerCenter,le=I.CompressionLevels[L].BytesPerScale,V=I.CompressionLevels[L].BytesPerRotation,se=I.CompressionLevels[L].BytesPerColor,Z=M,G=Z+ee,X=G+le,ce=X+V,de=ce+se;if(b[p]!==void 0?(i.set(b[p],b[A],b[C],b[g]),i.normalize()):i.set(1,0,0,0),b[u]!==void 0?r.set(b[u]||0,b[h]||0,b[f]||0):r.set(0,0,0),L===0){const Se=new Float32Array(D,Z,I.CenterComponentCount),pe=new Float32Array(D,X,I.RotationComponentCount),ne=new Float32Array(D,G,I.ScaleComponentCount);if(pe.set([i.x,i.y,i.z,i.w]),ne.set([r.x,r.y,r.z]),Se.set([b[l],b[c],b[d]]),R>0){const fe=new Float32Array(D,de,Q);if(R>=1){for(let $=0;$<9;$++)fe[$]=b[S+$]||0;if(R>=2)for(let $=0;$<15;$++)fe[$+9]=b[w+$]||0}}}else{const Se=new Uint16Array(e,0,I.CenterComponentCount),pe=new Uint16Array(t,0,I.RotationComponentCount),ne=new Uint16Array(s,0,I.ScaleComponentCount);if(pe.set([Ae(i.x),Ae(i.y),Ae(i.z),Ae(i.w)]),ne.set([Ae(r.x),Ae(r.y),Ae(r.z)]),a.set(b[l],b[c],b[d]).sub(O),a.x=F(a.x,k,U),a.y=F(a.y,k,U),a.z=F(a.z,k,U),Se.set([a.x,a.y,a.z]),R>0){const fe=L===1?Uint16Array:Uint8Array,$=L===1?2:1,Fe=new fe(o,0,Q);if(R>=1){for(let Ce=0;Ce<9;Ce++){const Be=b[S+Ce]||0;Fe[Ce]=L===1?Ae(Be):at(Be,_,H)}const be=9*$;if(Ke(Fe.buffer,0,D,de,be),R>=2){for(let Ce=0;Ce<15;Ce++){const Be=b[w+Ce]||0;Fe[Ce+9]=L===1?Ae(Be):at(Be,_,H)}Ke(Fe.buffer,be,D,de+be,15*$)}}}Ke(Se.buffer,0,D,Z,6),Ke(ne.buffer,0,D,G,6),Ke(pe.buffer,0,D,X,8)}const ie=new Uint8ClampedArray(n,0,4);ie.set([b[x]||0,b[B]||0,b[y]||0]),ie[3]=b[E]||0,Ke(ie.buffer,0,D,ce,4)}})();static generateFromUncompressedSplatArrays(e,s,t,n,o,i,r=[]){let a=0;for(let y=0;y<e.length;y++){const E=e[y];a=Math.max(E.sphericalHarmonicsDegree,a)}let l,c;for(let y=0;y<e.length;y++){const E=e[y];for(let S=0;S<E.splats.length;S++){const w=E.splats[S];for(let F=P.OFFSET.FRC0;F<P.OFFSET.FRC23&&F<w.length;F++)(!l||w[F]<l)&&(l=w[F]),(!c||w[F]>c)&&(c=w[F])}}l=l||-ze,c=c||ze;const{bytesPerSplat:d}=I.calculateComponentStorage(t,a),u=I.CompressionLevels[t].ScaleRange,h=[],f=[];let p=0;for(let y=0;y<e.length;y++){const E=e[y],S=new P(a);for(let Z=0;Z<E.splatCount;Z++){const G=E.splats[Z];(G[P.OFFSET.OPACITY]||0)>=s&&S.addSplat(G)}const w=r[y]||{},F=(w.blockSizeFactor||1)*(o||I.BucketBlockSize),b=Math.ceil((w.bucketSizeFactor||1)*(i||I.BucketSize)),D=I.computeBucketsForUncompressedSplatArray(S,F,b),M=D.fullBuckets.length,L=D.partiallyFullBuckets.map(Z=>Z.splats.length),R=L.length,O=[...D.fullBuckets,...D.partiallyFullBuckets],k=S.splats.length*d,U=R*4,_=t>=1?O.length*I.BucketStorageSizeBytes+U:0,H=k+_,Q=new ArrayBuffer(H),ee=u/(F*.5),le=new v;let V=0;for(let Z=0;Z<O.length;Z++){const G=O[Z];le.fromArray(G.center);for(let X=0;X<G.splats.length;X++){let ce=G.splats[X];const de=S.splats[ce],ie=_+V*d;I.writeSplatDataToSectionBuffer(de,Q,ie,t,a,le,ee,u,l,c),V++}}if(p+=V,t>=1){const Z=new Uint32Array(Q,0,L.length*4);for(let X=0;X<L.length;X++)Z[X]=L[X];const G=new Float32Array(Q,U,O.length*I.BucketStorageSizeFloats);for(let X=0;X<O.length;X++){const ce=O[X],de=X*3;G[de]=ce.center[0],G[de+1]=ce.center[1],G[de+2]=ce.center[2]}}h.push(Q);const se=new ArrayBuffer(I.SectionHeaderSizeBytes);I.writeSectionHeaderToBuffer({maxSplatCount:V,splatCount:V,bucketSize:b,bucketCount:O.length,bucketBlockSize:F,compressionScaleRange:u,storageSizeBytes:H,fullBucketCount:M,partiallyFilledBucketCount:R,sphericalHarmonicsDegree:a},t,se,0),f.push(se)}let A=0;for(let y of h)A+=y.byteLength;const C=I.HeaderSizeBytes+I.SectionHeaderSizeBytes*h.length+A,g=new ArrayBuffer(C);I.writeHeaderToBuffer({versionMajor:0,versionMinor:1,maxSectionCount:h.length,sectionCount:h.length,maxSplatCount:p,splatCount:p,compressionLevel:t,sceneCenter:n,minSphericalHarmonicsCoeff:l,maxSphericalHarmonicsCoeff:c},g);let x=I.HeaderSizeBytes;for(let y of f)new Uint8Array(g,x,I.SectionHeaderSizeBytes).set(new Uint8Array(y)),x+=I.SectionHeaderSizeBytes;for(let y of h)new Uint8Array(g,x,y.byteLength).set(new Uint8Array(y)),x+=y.byteLength;return new I(g)}static computeBucketsForUncompressedSplatArray(e,s,t){let n=e.splatCount;const o=s/2,i=new v,r=new v;for(let p=0;p<n;p++){const A=e.splats[p],C=[A[P.OFFSET.X],A[P.OFFSET.Y],A[P.OFFSET.Z]];(p===0||C[0]<i.x)&&(i.x=C[0]),(p===0||C[0]>r.x)&&(r.x=C[0]),(p===0||C[1]<i.y)&&(i.y=C[1]),(p===0||C[1]>r.y)&&(r.y=C[1]),(p===0||C[2]<i.z)&&(i.z=C[2]),(p===0||C[2]>r.z)&&(r.z=C[2])}const a=new v().copy(r).sub(i),l=Math.ceil(a.y/s),c=Math.ceil(a.z/s),d=new v,u=[],h={};for(let p=0;p<n;p++){const A=e.splats[p],C=[A[P.OFFSET.X],A[P.OFFSET.Y],A[P.OFFSET.Z]],g=Math.floor((C[0]-i.x)/s),x=Math.floor((C[1]-i.y)/s),B=Math.floor((C[2]-i.z)/s);d.x=g*s+i.x+o,d.y=x*s+i.y+o,d.z=B*s+i.z+o;const y=g*(l*c)+x*c+B;let E=h[y];E||(h[y]=E={splats:[],center:d.toArray()}),E.splats.push(p),E.splats.length>=t&&(u.push(E),h[y]=null)}const f=[];for(let p in h)if(h.hasOwnProperty(p)){const A=h[p];A&&f.push(A)}return{fullBuckets:u,partiallyFullBuckets:f}}static preallocateUncompressed(e,s){const t=I.CompressionLevels[0].SphericalHarmonicsDegrees[s],n=I.HeaderSizeBytes+I.SectionHeaderSizeBytes,o=n+t.BytesPerSplat*e,i=new ArrayBuffer(o);return I.writeHeaderToBuffer({versionMajor:I.CurrentMajorVersion,versionMinor:I.CurrentMinorVersion,maxSectionCount:1,sectionCount:1,maxSplatCount:e,splatCount:e,compressionLevel:0,sceneCenter:new v},i),I.writeSectionHeaderToBuffer({maxSplatCount:e,splatCount:e,bucketSize:0,bucketCount:0,bucketBlockSize:0,compressionScaleRange:0,storageSizeBytes:0,fullBucketCount:0,partiallyFilledBucketCount:0,sphericalHarmonicsDegree:s},0,i,I.HeaderSizeBytes),{splatBuffer:new I(i,!0),splatBufferDataOffsetBytes:n}}}const Is=new Uint8Array([112,108,121,10]),Ts=new Uint8Array([10,101,110,100,95,104,101,97,100,101,114,10]),Lt="end_header",kt=new Map([["char",Int8Array],["uchar",Uint8Array],["short",Int16Array],["ushort",Uint16Array],["int",Int32Array],["uint",Uint32Array],["float",Float32Array],["double",Float64Array]]),Re=(m,e)=>{const s=(1<<e)-1;return(m&s)/s},Bs=(m,e)=>{m.x=Re(e>>>21,11),m.y=Re(e>>>11,10),m.z=Re(e,11)},Nn=(m,e)=>{m.x=Re(e>>>24,8),m.y=Re(e>>>16,8),m.z=Re(e>>>8,8),m.w=Re(e,8)},Vn=(m,e)=>{const s=1/(Math.sqrt(2)*.5),t=(Re(e>>>20,10)-.5)*s,n=(Re(e>>>10,10)-.5)*s,o=(Re(e,10)-.5)*s,i=Math.sqrt(1-(t*t+n*n+o*o));switch(e>>>30){case 0:m.set(i,t,n,o);break;case 1:m.set(t,i,n,o);break;case 2:m.set(t,n,i,o);break;case 3:m.set(t,n,o,i);break}},Oe=(m,e,s)=>m*(1-s)+e*s,ae=(m,e)=>m.properties.find(s=>s.name===e&&s.storage)?.storage;class q{static decodeHeaderText(e){let s,t,n,o;const i=e.split(`
`).filter(d=>!d.startsWith("comment "));let r=0,a=!1;for(let d=1;d<i.length;++d){const u=i[d].split(" ");switch(u[0]){case"format":if(u[1]!=="binary_little_endian")throw new Error("Unsupported ply format");break;case"element":s={name:u[1],count:parseInt(u[2],10),properties:[],storageSizeBytes:0},s.name==="chunk"?t=s:s.name==="vertex"?n=s:s.name==="sh"&&(o=s);break;case"property":{if(!kt.has(u[1]))throw new Error(`Unrecognized property data type '${u[1]}' in ply header`);const h=kt.get(u[1]),f=h.BYTES_PER_ELEMENT*s.count;s.name==="vertex"&&(r+=h.BYTES_PER_ELEMENT),s.properties.push({type:u[1],name:u[2],storage:null,byteSize:h.BYTES_PER_ELEMENT,storageSizeByes:f}),s.storageSizeBytes+=f;break}case Lt:a=!0;break;default:throw new Error(`Unrecognized header value '${u[0]}' in ply header`)}if(a)break}let l=0,c=0;return o&&(c=o.properties.length,o.properties.length>=45?l=3:o.properties.length>=24?l=2:o.properties.length>=9&&(l=1)),{chunkElement:t,vertexElement:n,shElement:o,bytesPerSplat:r,headerSizeBytes:e.indexOf(Lt)+Lt.length+1,sphericalHarmonicsDegree:l,sphericalHarmonicsPerSplat:c}}static decodeHeader(e){const s=(h,f)=>{const p=h.length-f.length;let A,C;for(A=0;A<=p;++A){for(C=0;C<f.length&&h[A+C]===f[C];++C);if(C===f.length)return A}return-1},t=(h,f)=>{if(h.length<f.length)return!1;for(let p=0;p<f.length;++p)if(h[p]!==f[p])return!1;return!0};let n=new Uint8Array(e),o;if(n.length>=Is.length&&!t(n,Is))throw new Error("Invalid PLY header");if(o=s(n,Ts),o===-1)throw new Error("End of PLY header not found");const i=new TextDecoder("ascii").decode(n.slice(0,o)),{chunkElement:r,vertexElement:a,shElement:l,sphericalHarmonicsDegree:c,sphericalHarmonicsPerSplat:d,bytesPerSplat:u}=q.decodeHeaderText(i);return{headerSizeBytes:o+Ts.length,bytesPerSplat:u,chunkElement:r,vertexElement:a,shElement:l,sphericalHarmonicsDegree:c,sphericalHarmonicsPerSplat:d}}static readElementData(e,s,t,n,o,i=null){let r=s instanceof DataView?s:new DataView(s);n=n||0,o=o||e.count-1;for(let a=n;a<=o;++a)for(let l=0;l<e.properties.length;++l){const c=e.properties[l],d=kt.get(c.type),u=d.BYTES_PER_ELEMENT*e.count;if((!c.storage||c.storage.byteLength<u)&&(!i||i(c.name))&&(c.storage=new d(e.count)),c.storage)switch(c.type){case"char":c.storage[a]=r.getInt8(t);break;case"uchar":c.storage[a]=r.getUint8(t);break;case"short":c.storage[a]=r.getInt16(t,!0);break;case"ushort":c.storage[a]=r.getUint16(t,!0);break;case"int":c.storage[a]=r.getInt32(t,!0);break;case"uint":c.storage[a]=r.getUint32(t,!0);break;case"float":c.storage[a]=r.getFloat32(t,!0);break;case"double":c.storage[a]=r.getFloat64(t,!0);break}t+=c.byteSize}return t}static readPly(e,s=null){const t=q.decodeHeader(e);let n=q.readElementData(t.chunkElement,e,t.headerSizeBytes,null,null,s);return n=q.readElementData(t.vertexElement,e,n,null,null,s),q.readElementData(t.shElement,e,n,null,null,s),{chunkElement:t.chunkElement,vertexElement:t.vertexElement,shElement:t.shElement,sphericalHarmonicsDegree:t.sphericalHarmonicsDegree,sphericalHarmonicsPerSplat:t.sphericalHarmonicsPerSplat}}static getElementStorageArrays(e,s,t){const n={};if(s){const o=ae(e,"min_r"),i=ae(e,"min_g"),r=ae(e,"min_b"),a=ae(e,"max_r"),l=ae(e,"max_g"),c=ae(e,"max_b"),d=ae(e,"min_x"),u=ae(e,"min_y"),h=ae(e,"min_z"),f=ae(e,"max_x"),p=ae(e,"max_y"),A=ae(e,"max_z"),C=ae(e,"min_scale_x"),g=ae(e,"min_scale_y"),x=ae(e,"min_scale_z"),B=ae(e,"max_scale_x"),y=ae(e,"max_scale_y"),E=ae(e,"max_scale_z"),S=ae(s,"packed_position"),w=ae(s,"packed_rotation"),F=ae(s,"packed_scale"),b=ae(s,"packed_color");n.colorExtremes={minR:o,maxR:a,minG:i,maxG:l,minB:r,maxB:c},n.positionExtremes={minX:d,maxX:f,minY:u,maxY:p,minZ:h,maxZ:A},n.scaleExtremes={minScaleX:C,maxScaleX:B,minScaleY:g,maxScaleY:y,minScaleZ:x,maxScaleZ:E},n.position=S,n.rotation=w,n.scale=F,n.color=b}if(t){const o={};for(let i=0;i<45;i++){const r=`f_rest_${i}`,a=ae(t,r);if(a)o[r]=a;else break}n.sh=o}return n}static decompressBaseSplat=(function(){const e=new v,s=new ge,t=new v,n=new qt,o=P.OFFSET;return function(i,r,a,l,c,d,u,h,f,p){p=p||P.createSplat();const A=Math.floor((r+i)/256);return Bs(e,a[i]),Vn(s,u[i]),Bs(t,c[i]),Nn(n,f[i]),p[o.X]=Oe(l.minX[A],l.maxX[A],e.x),p[o.Y]=Oe(l.minY[A],l.maxY[A],e.y),p[o.Z]=Oe(l.minZ[A],l.maxZ[A],e.z),p[o.ROTATION0]=s.x,p[o.ROTATION1]=s.y,p[o.ROTATION2]=s.z,p[o.ROTATION3]=s.w,p[o.SCALE0]=Math.exp(Oe(d.minScaleX[A],d.maxScaleX[A],t.x)),p[o.SCALE1]=Math.exp(Oe(d.minScaleY[A],d.maxScaleY[A],t.y)),p[o.SCALE2]=Math.exp(Oe(d.minScaleZ[A],d.maxScaleZ[A],t.z)),h.minR&&h.maxR?p[o.FDC0]=re(Math.round(Oe(h.minR[A],h.maxR[A],n.x)*255),0,255):p[o.FDC0]=re(Math.floor(n.x*255),0,255),h.minG&&h.maxG?p[o.FDC1]=re(Math.round(Oe(h.minG[A],h.maxG[A],n.y)*255),0,255):p[o.FDC1]=re(Math.floor(n.y*255),0,255),h.minB&&h.maxB?p[o.FDC2]=re(Math.round(Oe(h.minB[A],h.maxB[A],n.z)*255),0,255):p[o.FDC2]=re(Math.floor(n.z*255),0,255),p[o.OPACITY]=re(Math.floor(n.w*255),0,255),p}})();static decompressSphericalHarmonics=(function(){const e=[0,3,8,15],s=[0,1,2,9,10,11,12,13,24,25,26,27,28,29,30,3,4,5,14,15,16,17,18,31,32,33,34,35,36,37,6,7,8,19,20,21,22,23,38,39,40,41,42,43,44];return function(t,n,o,i,r){r=r||P.createSplat();let a=e[o],l=e[i];for(let c=0;c<3;++c)for(let d=0;d<15;++d){const u=s[c*15+d];d<a&&d<l&&(r[P.OFFSET.FRC0+u]=n[c*l+d][t]*(8/255)-4)}return r}})();static parseToUncompressedSplatBufferSection(e,s,t,n,o,i,r,a,l=null){q.readElementData(s,i,0,t,n,l);const c=I.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat,{positionExtremes:d,scaleExtremes:u,colorExtremes:h,position:f,rotation:p,scale:A,color:C}=q.getElementStorageArrays(e,s),g=P.createSplat();for(let x=t;x<=n;++x){q.decompressBaseSplat(x,o,f,d,A,u,p,h,C,g);const B=x*c+a;I.writeSplatDataToSectionBuffer(g,r,B,0,0)}}static parseToUncompressedSplatArraySection(e,s,t,n,o,i,r,a=null){q.readElementData(s,i,0,t,n,a);const{positionExtremes:l,scaleExtremes:c,colorExtremes:d,position:u,rotation:h,scale:f,color:p}=q.getElementStorageArrays(e,s);for(let A=t;A<=n;++A){const C=P.createSplat();q.decompressBaseSplat(A,o,u,l,f,c,h,d,p,C),r.addSplat(C)}}static parseSphericalHarmonicsToUncompressedSplatArraySection(e,s,t,n,o,i,r,a,l,c=null){q.readElementData(s,o,i,t,n,c);const{sh:d}=q.getElementStorageArrays(e,void 0,s),u=Object.values(d);for(let h=t;h<=n;++h)q.decompressSphericalHarmonics(h,u,r,a,l.splats[h])}static parseToUncompressedSplatArray(e,s){const{chunkElement:t,vertexElement:n,shElement:o,sphericalHarmonicsDegree:i}=q.readPly(e);s=Math.min(s,i);const r=new P(s),{positionExtremes:a,scaleExtremes:l,colorExtremes:c,position:d,rotation:u,scale:h,color:f}=q.getElementStorageArrays(t,n);let p;if(s>0){const{sh:A}=q.getElementStorageArrays(t,void 0,o);p=Object.values(A)}for(let A=0;A<n.count;++A){r.addDefaultSplat();const C=r.getSplat(r.splatCount-1);q.decompressBaseSplat(A,0,d,a,h,l,u,c,f,C),s>0&&q.decompressSphericalHarmonics(A,p,s,i,C)}return r}static parseToUncompressedSplatBuffer(e,s){const{chunkElement:t,vertexElement:n,shElement:o,sphericalHarmonicsDegree:i}=q.readPly(e);s=Math.min(s,i);const{splatBuffer:r,splatBufferDataOffsetBytes:a}=I.preallocateUncompressed(n.count,s),{positionExtremes:l,scaleExtremes:c,colorExtremes:d,position:u,rotation:h,scale:f,color:p}=q.getElementStorageArrays(t,n);let A;if(s>0){const{sh:x}=q.getElementStorageArrays(t,void 0,o);A=Object.values(x)}const C=I.CompressionLevels[0].SphericalHarmonicsDegrees[s].BytesPerSplat,g=P.createSplat(s);for(let x=0;x<n.count;++x){q.decompressBaseSplat(x,0,u,l,f,c,h,d,p,g),s>0&&q.decompressSphericalHarmonics(x,A,s,i,g);const B=x*C+a;I.writeSplatDataToSectionBuffer(g,r.bufferData,B,0,s)}return r}}const Ie={INRIAV1:0,INRIAV2:1,PlayCanvasCompressed:2},[nn,Jt,Zt,$t,es,ts,ss]=[0,1,2,3,4,5,6],Es={double:nn,int:Jt,uint:Zt,float:$t,short:es,ushort:ts,uchar:ss},Gn={[nn]:8,[Jt]:4,[Zt]:4,[$t]:4,[es]:2,[ts]:2,[ss]:1};class W{static HeaderEndToken="end_header";static decodeSectionHeader(e,s,t=0){const n=[];let o=!1,i=-1,r=0,a=!1,l=null;const c=[],d=[],u=[],h={};for(let C=t;C<e.length;C++){const g=e[C].trim();if(g.startsWith("element"))if(o){i--;break}else{o=!0,t=C,i=C;const x=g.split(" ");let B=0;for(let y of x){const E=y.trim();E.length>0&&(B++,B===2?l=E:B===3&&(r=parseInt(E)))}}else if(g.startsWith("property")){const x=g.match(/(\w+)\s+(\w+)\s+(\w+)/);if(x){const B=x[2],y=x[3];u.push(y);const E=s[y];h[y]=B;const S=Es[B];E!==void 0&&(c.push(E),d[E]=S)}}if(g===W.HeaderEndToken){a=!0;break}o&&(n.push(g),i++)}const f=[];let p=0;for(let C of u){const g=h[C];if(h.hasOwnProperty(C)){const x=s[C];x!==void 0&&(f[x]=p)}p+=Gn[Es[g]]}const A=W.decodeSphericalHarmonicsFromSectionHeader(u,s);return{headerLines:n,headerStartLine:t,headerEndLine:i,fieldTypes:d,fieldIds:c,fieldOffsets:f,bytesPerVertex:p,vertexCount:r,dataSizeBytes:p*r,endOfHeader:a,sectionName:l,sphericalHarmonicsDegree:A.degree,sphericalHarmonicsCoefficientsPerChannel:A.coefficientsPerChannel,sphericalHarmonicsDegree1Fields:A.degree1Fields,sphericalHarmonicsDegree2Fields:A.degree2Fields}}static decodeSphericalHarmonicsFromSectionHeader(e,s){let t=0,n=0;for(let a of e)a.startsWith("f_rest")&&t++;n=t/3;let o=0;n>=3&&(o=1),n>=8&&(o=2);let i=[],r=[];for(let a=0;a<3;a++){if(o>=1)for(let l=0;l<3;l++)i.push(s["f_rest_"+(l+n*a)]);if(o>=2)for(let l=0;l<5;l++)r.push(s["f_rest_"+(l+n*a+3)])}return{degree:o,coefficientsPerChannel:n,degree1Fields:i,degree2Fields:r}}static getHeaderSectionNames(e){const s=[];for(let t of e)if(t.startsWith("element")){const n=t.split(" ");let o=0;for(let i of n){const r=i.trim();r.length>0&&(o++,o===2&&s.push(r))}}return s}static checkTextForEndHeader(e){return!!e.includes(W.HeaderEndToken)}static checkBufferForEndHeader(e,s,t,n){const o=new Uint8Array(e,Math.max(0,s-t),t),i=n.decode(o);return W.checkTextForEndHeader(i)}static extractHeaderFromBufferToText(e){const s=new TextDecoder;let t=0,n="";const o=100;for(;;){if(t+o>=e.byteLength)throw new Error("End of file reached while searching for end of header");const i=new Uint8Array(e,t,o);if(n+=s.decode(i),t+=o,W.checkBufferForEndHeader(e,t,o*2,s))break}return n}static readHeaderFromBuffer(e){const s=new TextDecoder;let t=0,n="";const o=100;for(;;){if(t+o>=e.byteLength)throw new Error("End of file reached while searching for end of header");const i=new Uint8Array(e,t,o);if(n+=s.decode(i),t+=o,W.checkBufferForEndHeader(e,t,o*2,s))break}return n}static convertHeaderTextToLines(e){const s=e.split(`
`),t=[];for(let n=0;n<s.length;n++){const o=s[n].trim();if(t.push(o),o===W.HeaderEndToken)break}return t}static determineHeaderFormatFromHeaderText(e){const s=W.convertHeaderTextToLines(e);let t=Ie.INRIAV1;for(let n=0;n<s.length;n++){const o=s[n].trim();if(o.startsWith("element chunk")||o.match(/[A-Za-z]*packed_[A-Za-z]*/))t=Ie.PlayCanvasCompressed;else if(o.startsWith("element codebook_centers"))t=Ie.INRIAV2;else if(o===W.HeaderEndToken)break}return t}static determineHeaderFormatFromPlyBuffer(e){const s=W.extractHeaderFromBufferToText(e);return W.determineHeaderFormatFromHeaderText(s)}static readVertex(e,s,t,n,o,i,r=!0){const a=t*s.bytesPerVertex+n,l=s.fieldOffsets,c=s.fieldTypes;for(let d of o){const u=c[d];u===$t?i[d]=e.getFloat32(a+l[d],!0):u===es?i[d]=e.getInt16(a+l[d],!0):u===ts?i[d]=e.getUint16(a+l[d],!0):u===Jt?i[d]=e.getInt32(a+l[d],!0):u===Zt?i[d]=e.getUint32(a+l[d],!0):u===ss&&(r?i[d]=e.getUint8(a+l[d])/255:i[d]=e.getUint8(a+l[d]))}}}const on=["scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity","red","green","blue","f_rest_0"],qn=on.map((m,e)=>e),[ws,Wn,Kn,jn,Yn,Xn,Jn,Zn,$n,eo,vs,to,so,Fs,Ds,no,oo,ro]=qn;class xe{static decodeHeaderLines(e){let s=0;e.forEach(c=>{c.includes("f_rest_")&&s++});let t=0;s>=45?t=45:s>=24?t=24:s>=9&&(t=9);let o=Array.from(Array(Math.max(t-1,0))).map((c,d)=>`f_rest_${d+1}`);const i=[...on,...o],r=i.map((c,d)=>d),a=r.reduce((c,d)=>(c[i[d]]=d,c),{}),l=W.decodeSectionHeader(e,a,0);return l.splatCount=l.vertexCount,l.bytesPerSplat=l.bytesPerVertex,l.fieldsToReadIndexes=r,l}static decodeHeaderText(e){const s=W.convertHeaderTextToLines(e),t=xe.decodeHeaderLines(s);return t.headerText=e,t.headerSizeBytes=e.indexOf(W.HeaderEndToken)+W.HeaderEndToken.length+1,t}static decodeHeaderFromBuffer(e){const s=W.readHeaderFromBuffer(e);return xe.decodeHeaderText(s)}static findSplatData(e,s){return new DataView(e,s.headerSizeBytes)}static parseToUncompressedSplatBufferSection(e,s,t,n,o,i,r,a=0){a=Math.min(a,e.sphericalHarmonicsDegree);const l=I.CompressionLevels[0].SphericalHarmonicsDegrees[a].BytesPerSplat;for(let c=s;c<=t;c++){const d=xe.parseToUncompressedSplat(n,c,e,o,a),u=c*l+r;I.writeSplatDataToSectionBuffer(d,i,u,0,a)}}static parseToUncompressedSplatArraySection(e,s,t,n,o,i,r=0){r=Math.min(r,e.sphericalHarmonicsDegree);for(let a=s;a<=t;a++){const l=xe.parseToUncompressedSplat(n,a,e,o,r);i.addSplat(l)}}static decodeSectionSplatData(e,s,t,n,o=!0){if(n=Math.min(n,t.sphericalHarmonicsDegree),o){const i=new P(n);for(let r=0;r<s;r++){const a=xe.parseToUncompressedSplat(e,r,t,0,n);i.addSplat(a)}return i}else{const{splatBuffer:i,splatBufferDataOffsetBytes:r}=I.preallocateUncompressed(s,n);return xe.parseToUncompressedSplatBufferSection(t,0,s-1,e,0,i.bufferData,r,n),i}}static parseToUncompressedSplat=(function(){let e=[];const s=new ge,t=P.OFFSET.X,n=P.OFFSET.Y,o=P.OFFSET.Z,i=P.OFFSET.SCALE0,r=P.OFFSET.SCALE1,a=P.OFFSET.SCALE2,l=P.OFFSET.ROTATION0,c=P.OFFSET.ROTATION1,d=P.OFFSET.ROTATION2,u=P.OFFSET.ROTATION3,h=P.OFFSET.FDC0,f=P.OFFSET.FDC1,p=P.OFFSET.FDC2,A=P.OFFSET.OPACITY,C=[];for(let g=0;g<45;g++)C[g]=P.OFFSET.FRC0+g;return function(g,x,B,y=0,E=0){E=Math.min(E,B.sphericalHarmonicsDegree),xe.readSplat(g,B,x,y,e);const S=P.createSplat(E);if(e[ws]!==void 0?(S[i]=Math.exp(e[ws]),S[r]=Math.exp(e[Wn]),S[a]=Math.exp(e[Kn])):(S[i]=.01,S[r]=.01,S[a]=.01),e[vs]!==void 0){const w=.28209479177387814;S[h]=(.5+w*e[vs])*255,S[f]=(.5+w*e[to])*255,S[p]=(.5+w*e[so])*255}else e[Ds]!==void 0?(S[h]=e[Ds]*255,S[f]=e[no]*255,S[p]=e[oo]*255):(S[h]=0,S[f]=0,S[p]=0);if(e[Fs]!==void 0&&(S[A]=1/(1+Math.exp(-e[Fs]))*255),S[h]=re(Math.floor(S[h]),0,255),S[f]=re(Math.floor(S[f]),0,255),S[p]=re(Math.floor(S[p]),0,255),S[A]=re(Math.floor(S[A]),0,255),E>=1&&e[ro]!==void 0){for(let w=0;w<9;w++)S[C[w]]=e[B.sphericalHarmonicsDegree1Fields[w]];if(E>=2)for(let w=0;w<15;w++)S[C[9+w]]=e[B.sphericalHarmonicsDegree2Fields[w]]}return s.set(e[jn],e[Yn],e[Xn],e[Jn]),s.normalize(),S[l]=s.x,S[c]=s.y,S[d]=s.z,S[u]=s.w,S[t]=e[Zn],S[n]=e[$n],S[o]=e[eo],S}})();static readSplat(e,s,t,n,o){return W.readVertex(e,s,t,n,s.fieldsToReadIndexes,o,!0)}static parseToUncompressedSplatArray(e,s=0){const{header:t,splatCount:n,splatData:o}=bs(e);return xe.decodeSectionSplatData(o,n,t,s,!0)}static parseToUncompressedSplatBuffer(e,s=0){const{header:t,splatCount:n,splatData:o}=bs(e);return xe.decodeSectionSplatData(o,n,t,s,!1)}}function bs(m){const e=xe.decodeHeaderFromBuffer(m),s=e.splatCount,t=xe.findSplatData(m,e);return{header:e,splatCount:s,splatData:t}}const rn=["features_dc","features_rest_0","features_rest_1","features_rest_2","features_rest_3","features_rest_4","features_rest_5","features_rest_6","features_rest_7","features_rest_8","features_rest_9","features_rest_10","features_rest_11","features_rest_12","features_rest_13","features_rest_14","opacity","scaling","rotation_re","rotation_im"],gt=rn.map((m,e)=>e),[Ct,io,ao,Rs,St,lo,Ht]=[0,1,4,16,17,18,19],an=["scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity","red","green","blue","f_rest_0","f_rest_1","f_rest_2","f_rest_3","f_rest_4","f_rest_5","f_rest_6","f_rest_7","f_rest_8","f_rest_9","f_rest_10","f_rest_11","f_rest_12","f_rest_13","f_rest_14","f_rest_15","f_rest_16","f_rest_17","f_rest_18","f_rest_19","f_rest_20","f_rest_21","f_rest_22","f_rest_23","f_rest_24","f_rest_25","f_rest_26","f_rest_27","f_rest_28","f_rest_29","f_rest_30","f_rest_31","f_rest_32","f_rest_33","f_rest_34","f_rest_35","f_rest_36","f_rest_37","f_rest_38","f_rest_39","f_rest_40","f_rest_41","f_rest_42","f_rest_43","f_rest_44","f_rest_45"],Vt=an.map((m,e)=>e),[Ms,co,ho,uo,po,fo,mo,Ao,go,Co,Gt,ln,cn,Ps]=Vt,Os=Gt,So=ln,yo=cn,yt=m=>{const e=(31744&m)>>10,s=1023&m;return(m>>15?-1:1)*(e?e===31?s?NaN:1/0:Math.pow(2,e-15)*(1+s/1024):s/1024*6103515625e-14)};class we{static decodeSectionHeadersFromHeaderLines(e){const s=Vt.reduce((c,d)=>(c[an[d]]=d,c),{}),t=gt.reduce((c,d)=>(c[rn[d]]=d,c),{}),n=W.getHeaderSectionNames(e);let o;for(let c=0;c<n.length;c++)n[c]==="codebook_centers"&&(o=c);let i=0,r=!1;const a=[];let l=0;for(;!r;){let c;l===o?c=W.decodeSectionHeader(e,t,i):c=W.decodeSectionHeader(e,s,i),r=c.endOfHeader,i=c.headerEndLine+1,r||(c.splatCount=c.vertexCount,c.bytesPerSplat=c.bytesPerVertex),a.push(c),l++}return a}static decodeSectionHeadersFromHeaderText(e){const s=W.convertHeaderTextToLines(e);return we.decodeSectionHeadersFromHeaderLines(s)}static getSplatCountFromSectionHeaders(e){let s=0;for(let t of e)t.sectionName!=="codebook_centers"&&(s+=t.vertexCount);return s}static decodeHeaderFromHeaderText(e){const s=e.indexOf(W.HeaderEndToken)+W.HeaderEndToken.length+1,t=we.decodeSectionHeadersFromHeaderText(e),n=we.getSplatCountFromSectionHeaders(t);return{headerSizeBytes:s,sectionHeaders:t,splatCount:n}}static decodeHeaderFromBuffer(e){const s=W.readHeaderFromBuffer(e);return we.decodeHeaderFromHeaderText(s)}static findVertexData(e,s,t){let n=s.headerSizeBytes;for(let o=0;o<t&&o<s.sectionHeaders.length;o++){const i=s.sectionHeaders[o];n+=i.dataSizeBytes}return new DataView(e,n,s.sectionHeaders[t].dataSizeBytes)}static decodeCodeBook(e,s){const t=[],n=[];for(let o=0;o<s.vertexCount;o++){W.readVertex(e,s,o,0,gt,t);for(let i of gt){const r=gt[i];let a=n[r];a||(n[r]=a=[]),a.push(t[i])}}for(let o=0;o<n.length;o++){const i=n[o],r=.28209479177387814;for(let a=0;a<i.length;a++){const l=yt(i[a]);o===Rs?i[a]=Math.round(1/(1+Math.exp(-l))*255):o===Ct?i[a]=Math.round((.5+r*l)*255):o===St?i[a]=Math.exp(l):i[a]=l}}return n}static decodeSectionSplatData(e,s,t,n,o){o=Math.min(o,t.sphericalHarmonicsDegree);const i=new P(o);for(let r=0;r<s;r++){const a=we.parseToUncompressedSplat(e,r,t,n,0,o);i.addSplat(a)}return i}static parseToUncompressedSplat=(function(){let e=[];const s=new ge,t=P.OFFSET.X,n=P.OFFSET.Y,o=P.OFFSET.Z,i=P.OFFSET.SCALE0,r=P.OFFSET.SCALE1,a=P.OFFSET.SCALE2,l=P.OFFSET.ROTATION0,c=P.OFFSET.ROTATION1,d=P.OFFSET.ROTATION2,u=P.OFFSET.ROTATION3,h=P.OFFSET.FDC0,f=P.OFFSET.FDC1,p=P.OFFSET.FDC2,A=P.OFFSET.OPACITY,C=[];for(let g=0;g<45;g++)C[g]=P.OFFSET.FRC0+g;return function(g,x,B,y,E=0,S=0){S=Math.min(S,B.sphericalHarmonicsDegree),we.readSplat(g,B,x,E,e);const w=P.createSplat(S);if(e[Ms]!==void 0?(w[i]=y[St][e[Ms]],w[r]=y[St][e[co]],w[a]=y[St][e[ho]]):(w[i]=.01,w[r]=.01,w[a]=.01),e[Gt]!==void 0?(w[h]=y[Ct][e[Gt]],w[f]=y[Ct][e[ln]],w[p]=y[Ct][e[cn]]):e[Os]!==void 0?(w[h]=e[Os]*255,w[f]=e[So]*255,w[p]=e[yo]*255):(w[h]=0,w[f]=0,w[p]=0),e[Ps]!==void 0&&(w[A]=y[Rs][e[Ps]]),w[h]=re(Math.floor(w[h]),0,255),w[f]=re(Math.floor(w[f]),0,255),w[p]=re(Math.floor(w[p]),0,255),w[A]=re(Math.floor(w[A]),0,255),S>=1&&B.sphericalHarmonicsDegree>=1){for(let L=0;L<9;L++){const R=y[io+L%3];w[C[L]]=R[e[B.sphericalHarmonicsDegree1Fields[L]]]}if(S>=2&&B.sphericalHarmonicsDegree>=2)for(let L=0;L<15;L++){const R=y[ao+L%5];w[C[9+L]]=R[e[B.sphericalHarmonicsDegree2Fields[L]]]}}const F=y[lo][e[uo]],b=y[Ht][e[po]],D=y[Ht][e[fo]],M=y[Ht][e[mo]];return s.set(F,b,D,M),s.normalize(),w[l]=s.x,w[c]=s.y,w[d]=s.z,w[u]=s.w,w[t]=yt(e[Ao]),w[n]=yt(e[go]),w[o]=yt(e[Co]),w}})();static readSplat(e,s,t,n,o){return W.readVertex(e,s,t,n,Vt,o,!1)}static parseToUncompressedSplatArray(e,s=0){const t=[],n=we.decodeHeaderFromBuffer(e,s);let o;for(let r=0;r<n.sectionHeaders.length;r++){const a=n.sectionHeaders[r];if(a.sectionName==="codebook_centers"){const l=we.findVertexData(e,n,r);o=we.decodeCodeBook(l,a)}}for(let r=0;r<n.sectionHeaders.length;r++){const a=n.sectionHeaders[r];if(a.sectionName!=="codebook_centers"){const l=a.vertexCount,c=we.findVertexData(e,n,r),d=we.decodeSectionSplatData(c,l,a,o,s);t.push(d)}}const i=new P(s);for(let r of t)for(let a of r.splats)i.addSplat(a);return i}}class Ls{static parseToUncompressedSplatArray(e,s=0){const t=W.determineHeaderFormatFromPlyBuffer(e);if(t===Ie.PlayCanvasCompressed)return q.parseToUncompressedSplatArray(e,s);if(t===Ie.INRIAV1)return xe.parseToUncompressedSplatArray(e,s);if(t===Ie.INRIAV2)return we.parseToUncompressedSplatArray(e,s)}static parseToUncompressedSplatBuffer(e,s=0){const t=W.determineHeaderFormatFromPlyBuffer(e);if(t===Ie.PlayCanvasCompressed)return q.parseToUncompressedSplatBuffer(e,s);if(t===Ie.INRIAV1)return xe.parseToUncompressedSplatBuffer(e,s);if(t===Ie.INRIAV2)throw new Error("parseToUncompressedSplatBuffer() is not implemented for INRIA V2 PLY files")}}class ns{constructor(e,s,t,n){this.sectionCount=e,this.sectionFilters=s,this.groupingParameters=t,this.partitionGenerator=n}partitionUncompressedSplatArray(e){let s,t,n;if(this.partitionGenerator){const i=this.partitionGenerator(e);s=i.groupingParameters,t=i.sectionCount,n=i.sectionFilters}else s=this.groupingParameters,t=this.sectionCount,n=this.sectionFilters;const o=[];for(let i=0;i<t;i++){const r=new P(e.sphericalHarmonicsDegree),a=n[i];for(let l=0;l<e.splatCount;l++)a(l)&&r.addSplat(e.splats[l]);o.push(r)}return{splatArrays:o,parameters:s}}static getStandardPartitioner(e=0,s=new v,t=I.BucketBlockSize,n=I.BucketSize){const o=i=>{const r=P.OFFSET.X,a=P.OFFSET.Y,l=P.OFFSET.Z;e<=0&&(e=i.splatCount);const c=new v,d=.5,u=C=>{C.x=Math.floor(C.x/d)*d,C.y=Math.floor(C.y/d)*d,C.z=Math.floor(C.z/d)*d};i.splats.forEach(C=>{c.set(C[r],C[a],C[l]).sub(s),u(c),C.centerDist=c.lengthSq()}),i.splats.sort((C,g)=>{let x=C.centerDist,B=g.centerDist;return x>B?1:-1});const h=[],f=[];e=Math.min(i.splatCount,e);const p=Math.ceil(i.splatCount/e);let A=0;for(let C=0;C<p;C++){let g=A;h.push(x=>x>=g&&x<g+e),f.push({blocksSize:t,bucketSize:n}),A+=e}return{sectionCount:h.length,sectionFilters:h,groupingParameters:f}};return new ns(void 0,void 0,void 0,o)}}class ft{constructor(e,s,t,n,o,i,r){this.splatPartitioner=e,this.alphaRemovalThreshold=s,this.compressionLevel=t,this.sectionSize=n,this.sceneCenter=o?new v().copy(o):void 0,this.blockSize=i,this.bucketSize=r}generateFromUncompressedSplatArray(e){const s=this.splatPartitioner.partitionUncompressedSplatArray(e);return I.generateFromUncompressedSplatArrays(s.splatArrays,this.alphaRemovalThreshold,this.compressionLevel,this.sceneCenter,this.blockSize,this.bucketSize,s.parameters)}static getStandardGenerator(e=1,s=1,t=0,n=new v,o=I.BucketBlockSize,i=I.BucketSize){const r=ns.getStandardPartitioner(t,n,o,i);return new ft(r,e,s,t,n,o,i)}}const ue={Downloading:0,Processing:1,Done:2};class wt extends Error{constructor(e){super(e)}}const te={ProgressiveToSplatBuffer:0,ProgressiveToSplatArray:1,DownloadBeforeProcessing:2};function ks(m,e){let s=0;for(let n of m)s+=n.sizeBytes;(!e||e.byteLength<s)&&(e=new ArrayBuffer(s));let t=0;for(let n of m)new Uint8Array(e,t,n.sizeBytes).set(n.data),t+=n.sizeBytes;return e}function Hs(m,e,s,t,n,o,i,r){return e?ft.getStandardGenerator(s,t,n,o,i,r).generateFromUncompressedSplatArray(m):I.generateFromUncompressedSplatArrays([m],s,0,new v)}class os{static loadFromURL(e,s,t,n,o,i,r=!0,a=0,l,c,d,u,h){let f;!t&&!r?f=te.DownloadBeforeProcessing:r?f=te.ProgressiveToSplatArray:f=te.ProgressiveToSplatBuffer;const p=Y.ProgressiveLoadSectionSize,A=I.HeaderSizeBytes+I.SectionHeaderSizeBytes,C=1;let g,x,B,y,E,S=0,w=0,F=0,b=!1,D=!1,M=!1;const L=Kt();let R=0,O=0,k=0,U=0,_="",H=null,Q=[],ee;const le=new TextDecoder,V=(se,Z,G)=>{const X=se>=100;if(G&&(Q.push({data:G,sizeBytes:G.byteLength,startBytes:k,endBytes:k+G.byteLength}),k+=G.byteLength),f===te.DownloadBeforeProcessing)X&&L.resolve(Q);else{if(b){if(g===Ie.PlayCanvasCompressed&&!D){const ce=H.headerSizeBytes+H.chunkElement.storageSizeBytes;E=ks(Q,E),E.byteLength>=ce&&(q.readElementData(H.chunkElement,E,H.headerSizeBytes),R=ce,O=ce,D=!0)}}else if(_+=le.decode(G),W.checkTextForEndHeader(_)){if(g=W.determineHeaderFormatFromHeaderText(_),g===Ie.INRIAV1)H=xe.decodeHeaderText(_),a=Math.min(a,H.sphericalHarmonicsDegree),S=H.splatCount,D=!0,U=H.headerSizeBytes+H.bytesPerSplat*S;else if(g===Ie.PlayCanvasCompressed){if(H=q.decodeHeaderText(_),a=Math.min(a,H.sphericalHarmonicsDegree),f===te.ProgressiveToSplatBuffer&&a>0)throw new wt("PlyLoader.loadFromURL() -> Selected PLY format has spherical harmonics data that cannot be progressively loaded.");S=H.vertexElement.count,U=H.headerSizeBytes+H.bytesPerSplat*S+H.chunkElement.storageSizeBytes}else{if(f===te.ProgressiveToSplatBuffer)throw new wt("PlyLoader.loadFromURL() -> Selected PLY format cannot be progressively loaded.");f=te.DownloadBeforeProcessing;return}if(f===te.ProgressiveToSplatBuffer){const ce=I.CompressionLevels[0].SphericalHarmonicsDegrees[a],de=A+ce.BytesPerSplat*S;B=new ArrayBuffer(de),I.writeHeaderToBuffer({versionMajor:I.CurrentMajorVersion,versionMinor:I.CurrentMinorVersion,maxSectionCount:C,sectionCount:C,maxSplatCount:S,splatCount:0,compressionLevel:0,sceneCenter:new v},B)}else ee=new P(a);R=H.headerSizeBytes,O=H.headerSizeBytes,b=!0}if(b&&D&&Q.length>0&&(x=ks(Q,x),k-R>p||k>=U&&!M||X)){const de=M?H.sphericalHarmonicsPerSplat:H.bytesPerSplat,Se=(M?k:Math.min(U,k))-O,pe=Math.floor(Se/de),ne=pe*de,fe=k-O-ne,$=O-Q[0].startBytes,Fe=new DataView(x,$,ne);if(M)g===Ie.PlayCanvasCompressed&&f===te.ProgressiveToSplatArray&&(q.parseSphericalHarmonicsToUncompressedSplatArraySection(H.chunkElement,H.shElement,F,F+pe-1,Fe,0,a,H.sphericalHarmonicsDegree,ee),F+=pe);else{if(f===te.ProgressiveToSplatBuffer){const be=I.CompressionLevels[0].SphericalHarmonicsDegrees[a],Ce=w*be.BytesPerSplat+A;g===Ie.PlayCanvasCompressed?q.parseToUncompressedSplatBufferSection(H.chunkElement,H.vertexElement,0,pe-1,w,Fe,B,Ce):xe.parseToUncompressedSplatBufferSection(H,0,pe-1,Fe,0,B,Ce,a)}else g===Ie.PlayCanvasCompressed?q.parseToUncompressedSplatArraySection(H.chunkElement,H.vertexElement,0,pe-1,w,Fe,ee):xe.parseToUncompressedSplatArraySection(H,0,pe-1,Fe,0,ee,a);w+=pe,f===te.ProgressiveToSplatBuffer&&(y||(I.writeSectionHeaderToBuffer({maxSplatCount:S,splatCount:w,bucketSize:0,bucketCount:0,bucketBlockSize:0,compressionScaleRange:0,storageSizeBytes:0,fullBucketCount:0,partiallyFilledBucketCount:0,sphericalHarmonicsDegree:a},0,B,I.HeaderSizeBytes),y=new I(B,!1)),y.updateLoadedCounts(1,w)),k>=U&&(M=!0)}if(fe===0)Q=[];else{let be=[],Ce=0;for(let Be=Q.length-1;Be>=0;Be--){const ke=Q[Be];if(Ce+=ke.sizeBytes,be.unshift(ke),Ce>=fe)break}Q=be}R+=p,O+=ne}n&&y&&n(y,X),X&&(f===te.ProgressiveToSplatBuffer?L.resolve(y):L.resolve(ee))}s&&s(se,Z,ue.Downloading)};return s&&s(0,"0%",ue.Downloading),Dt(e,V,!1,l).then(()=>(s&&s(0,"0%",ue.Processing),L.promise.then(se=>{if(s&&s(100,"100%",ue.Done),f===te.DownloadBeforeProcessing){const Z=Q.map(G=>G.data);return new Blob(Z).arrayBuffer().then(G=>os.loadFromFileData(G,o,i,r,a,c,d,u,h))}else return f===te.ProgressiveToSplatBuffer?se:ve(()=>Hs(se,r,o,i,c,d,u,h))})))}static loadFromFileData(e,s,t,n,o=0,i,r,a,l){return n?ve(()=>Ls.parseToUncompressedSplatArray(e,o)).then(c=>Hs(c,n,s,t,i,r,a,l)):ve(()=>Ls.parseToUncompressedSplatBuffer(e,o))}}const xo=m=>new ReadableStream({async start(e){e.enqueue(m),e.close()}});async function Io(m){try{const e=xo(m);if(!e)throw new Error("Failed to create stream from data");return await To(e)}catch(e){throw console.error("Error decompressing gzipped data:",e),e}}async function To(m){const e=m.pipeThrough(new DecompressionStream("gzip")),t=await new Response(e).arrayBuffer();return new Uint8Array(t)}const Bo=1347635022,Eo=1,wo=.15;function vo(m){const e=m>>15&1,s=m>>10&31,t=m&1023,n=e===1?-1:1;return s===0?n*Math.pow(2,-14)*t/1024:s===31?t!==0?NaN:n*(1/0):n*Math.pow(2,s-15)*(1+t/1024)}function Fo(m){return(m-128)/128}function Ne(m){switch(m){case 0:return 0;case 1:return 3;case 2:return 8;case 3:return 15;default:return console.error(`[SPZ: ERROR] Unsupported SH degree: ${m}`),0}}const Do=(function(){let m=[];const e=new ge,s=P.OFFSET.X,t=P.OFFSET.Y,n=P.OFFSET.Z,o=P.OFFSET.SCALE0,i=P.OFFSET.SCALE1,r=P.OFFSET.SCALE2,a=P.OFFSET.ROTATION0,l=P.OFFSET.ROTATION1,c=P.OFFSET.ROTATION2,d=P.OFFSET.ROTATION3,u=P.OFFSET.FDC0,h=P.OFFSET.FDC1,f=P.OFFSET.FDC2,p=P.OFFSET.OPACITY,A=[Ne(0),Ne(1),Ne(2),Ne(3)],C=[0,1,2,9,10,11,12,13,24,25,26,27,28,29,30,3,4,5,14,15,16,17,18,31,32,33,34,35,36,37,6,7,8,19,20,21,22,23,38,39,40,41,42,43,44];return function(g,x,B){B=Math.min(x,B);const y=P.createSplat(B);g.scale[0]!==void 0?(y[o]=g.scale[0],y[i]=g.scale[1],y[r]=g.scale[2]):(y[o]=.01,y[i]=.01,y[r]=.01),g.color[0]!==void 0?(y[u]=g.color[0],y[h]=g.color[1],y[f]=g.color[2]):m[RED]!==void 0?(y[u]=m[RED]*255,y[h]=m[GREEN]*255,y[f]=m[BLUE]*255):(y[u]=0,y[h]=0,y[f]=0),g.alpha!==void 0&&(y[p]=g.alpha),y[u]=re(Math.floor(y[u]),0,255),y[h]=re(Math.floor(y[h]),0,255),y[f]=re(Math.floor(y[f]),0,255),y[p]=re(Math.floor(y[p]),0,255);let E=A[B],S=A[x];for(let w=0;w<3;++w)for(let F=0;F<15;++F){const b=C[w*15+F];F<E&&F<S&&(y[P.OFFSET.FRC0+b]=g.sh[w*S+F])}return e.set(g.rotation[3],g.rotation[0],g.rotation[1],g.rotation[2]),e.normalize(),y[a]=e.x,y[l]=e.y,y[c]=e.z,y[d]=e.w,y[s]=g.position[0],y[t]=g.position[1],y[n]=g.position[2],y}})();function bo(m,e,s,t){return!(m.positions.length!==e*3*(t?2:3)||m.scales.length!==e*3||m.rotations.length!==e*3||m.alphas.length!==e||m.colors.length!==e*3||m.sh.length!==e*s*3)}function Us(m,e,s,t,n){e=Math.min(e,m.shDegree);const o=m.numPoints,i=Ne(m.shDegree),r=m.positions.length===o*3*2;if(!bo(m,o,i,r))return null;const a={position:[],scale:[],rotation:[],alpha:void 0,color:[],sh:[]};let l;r&&(l=new Uint16Array(m.positions.buffer,m.positions.byteOffset,o*3));const c=1/(1<<m.fractionalBits),d=Ne(m.shDegree),u=.28209479177387814;for(let h=0;h<o;h++){if(r)for(let g=0;g<3;g++)a.position[g]=vo(l[h*3+g]);else for(let g=0;g<3;g++){const x=h*9+g*3;let B=m.positions[x];B|=m.positions[x+1]<<8,B|=m.positions[x+2]<<16,B|=B&8388608?4278190080:0,a.position[g]=B*c}for(let g=0;g<3;g++)a.scale[g]=Math.exp(m.scales[h*3+g]/16-10);const f=m.rotations.subarray(h*3,h*3+3),p=[f[0]/127.5-1,f[1]/127.5-1,f[2]/127.5-1];a.rotation[0]=p[0],a.rotation[1]=p[1],a.rotation[2]=p[2];const A=p[0]*p[0]+p[1]*p[1]+p[2]*p[2];a.rotation[3]=Math.sqrt(Math.max(0,1-A)),a.alpha=Math.floor(m.alphas[h]);for(let g=0;g<3;g++)a.color[g]=Math.floor(((m.colors[h*3+g]/255-.5)/wo*u+.5)*255);for(let g=0;g<3;g++)for(let x=0;x<d;x++)a.sh[g*d+x]=Fo(m.sh[d*3*h+x*3+g]);const C=Do(a,m.shDegree,e);if(s){const g=I.CompressionLevels[0].SphericalHarmonicsDegrees[e].BytesPerSplat,x=h*g+n;I.writeSplatDataToSectionBuffer(C,t,x,0,e)}else t.addSplat(C)}}const Ro=16,Mo=1e7;function Po(m){const e=new DataView(m);let s=0;const t={magic:e.getUint32(s,!0),version:e.getUint32(s+4,!0),numPoints:e.getUint32(s+8,!0),shDegree:e.getUint8(s+12),fractionalBits:e.getUint8(s+13),flags:e.getUint8(s+14),reserved:e.getUint8(s+15)};if(s+=Ro,t.magic!==Bo)return console.error("[SPZ ERROR] deserializePackedGaussians: header not found"),null;if(t.version<1||t.version>2)return console.error(`[SPZ ERROR] deserializePackedGaussians: version not supported: ${t.version}`),null;if(t.numPoints>Mo)return console.error(`[SPZ ERROR] deserializePackedGaussians: Too many points: ${t.numPoints}`),null;if(t.shDegree>3)return console.error(`[SPZ ERROR] deserializePackedGaussians: Unsupported SH degree: ${t.shDegree}`),null;const n=t.numPoints,o=Ne(t.shDegree),i=t.version===1,r={numPoints:n,shDegree:t.shDegree,fractionalBits:t.fractionalBits,antialiased:(t.flags&Eo)!==0,positions:new Uint8Array(n*3*(i?2:3)),scales:new Uint8Array(n*3),rotations:new Uint8Array(n*3),alphas:new Uint8Array(n),colors:new Uint8Array(n*3),sh:new Uint8Array(n*o*3)};try{const a=new Uint8Array(m);let l=r.positions.length,c=s;if(r.positions.set(a.slice(c,c+l)),c+=l,r.alphas.set(a.slice(c,c+r.alphas.length)),c+=r.alphas.length,r.colors.set(a.slice(c,c+r.colors.length)),c+=r.colors.length,r.scales.set(a.slice(c,c+r.scales.length)),c+=r.scales.length,r.rotations.set(a.slice(c,c+r.rotations.length)),c+=r.rotations.length,r.sh.set(a.slice(c,c+r.sh.length)),c+r.sh.length!==m.byteLength)return console.error("[SPZ ERROR] deserializePackedGaussians: incorrect buffer size"),null}catch(a){return console.error("[SPZ ERROR] deserializePackedGaussians: read error",a),null}return r}async function Oo(m){try{const e=await Io(m);return Po(e.buffer)}catch(e){return console.error("[SPZ ERROR] loadSpzPacked: decompression error",e),null}}class rs{static loadFromURL(e,s,t,n,o=!0,i=0,r,a,l,c,d){return s&&s(0,"0%",ue.Downloading),Dt(e,s,!0,r).then(u=>(s&&s(0,"0%",ue.Processing),rs.loadFromFileData(u,t,n,o,i,a,l,c,d)))}static async loadFromFileData(e,s,t,n,o=0,i,r,a,l){await ve();const c=await Oo(e);o=Math.min(c.shDegree,o);const d=new P(o);if(n)return Us(c,o,!1,d,0),ft.getStandardGenerator(s,t,i,r,a,l).generateFromUncompressedSplatArray(d);{const{splatBuffer:u,splatBufferDataOffsetBytes:h}=I.preallocateUncompressed(c.numPoints,o);return Us(c,o,!0,u.bufferData,h),u}}}class j{static RowSizeBytes=32;static CenterSizeBytes=12;static ScaleSizeBytes=12;static RotationSizeBytes=4;static ColorSizeBytes=4;static parseToUncompressedSplatBufferSection(e,s,t,n,o,i){const r=I.CompressionLevels[0].BytesPerCenter,a=I.CompressionLevels[0].BytesPerScale,l=I.CompressionLevels[0].BytesPerRotation,c=I.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat;for(let d=e;d<=s;d++){const u=d*j.RowSizeBytes+n,h=new Float32Array(t,u,3),f=new Float32Array(t,u+j.CenterSizeBytes,3),p=new Uint8Array(t,u+j.CenterSizeBytes+j.ScaleSizeBytes,4),A=new Uint8Array(t,u+j.CenterSizeBytes+j.ScaleSizeBytes+j.RotationSizeBytes,4),C=new ge((A[1]-128)/128,(A[2]-128)/128,(A[3]-128)/128,(A[0]-128)/128);C.normalize();const g=d*c+i,x=new Float32Array(o,g,3),B=new Float32Array(o,g+r,3),y=new Float32Array(o,g+r+a,4),E=new Uint8Array(o,g+r+a+l,4);x[0]=h[0],x[1]=h[1],x[2]=h[2],B[0]=f[0],B[1]=f[1],B[2]=f[2],y[0]=C.w,y[1]=C.x,y[2]=C.y,y[3]=C.z,E[0]=p[0],E[1]=p[1],E[2]=p[2],E[3]=p[3]}}static parseToUncompressedSplatArraySection(e,s,t,n,o){for(let i=e;i<=s;i++){const r=i*j.RowSizeBytes+n,a=new Float32Array(t,r,3),l=new Float32Array(t,r+j.CenterSizeBytes,3),c=new Uint8Array(t,r+j.CenterSizeBytes+j.ScaleSizeBytes,4),d=new Uint8Array(t,r+j.CenterSizeBytes+j.ScaleSizeBytes+j.RotationSizeBytes,4),u=new ge((d[1]-128)/128,(d[2]-128)/128,(d[3]-128)/128,(d[0]-128)/128);u.normalize(),o.addSplatFromComonents(a[0],a[1],a[2],l[0],l[1],l[2],u.w,u.x,u.y,u.z,c[0],c[1],c[2],c[3])}}static parseStandardSplatToUncompressedSplatArray(e){const s=e.byteLength/j.RowSizeBytes,t=new P;for(let n=0;n<s;n++){const o=n*j.RowSizeBytes,i=new Float32Array(e,o,3),r=new Float32Array(e,o+j.CenterSizeBytes,3),a=new Uint8Array(e,o+j.CenterSizeBytes+j.ScaleSizeBytes,4),l=new Uint8Array(e,o+j.CenterSizeBytes+j.ScaleSizeBytes+j.ColorSizeBytes,4),c=new ge((l[1]-128)/128,(l[2]-128)/128,(l[3]-128)/128,(l[0]-128)/128);c.normalize(),t.addSplatFromComonents(i[0],i[1],i[2],r[0],r[1],r[2],c.w,c.x,c.y,c.z,a[0],a[1],a[2],a[3])}return t}}function zs(m,e,s,t,n,o,i,r){return e?ft.getStandardGenerator(s,t,n,o,i,r).generateFromUncompressedSplatArray(m):I.generateFromUncompressedSplatArrays([m],s,0,new v)}class is{static loadFromURL(e,s,t,n,o,i,r=!0,a,l,c,d,u){let h=t?te.ProgressiveToSplatBuffer:te.ProgressiveToSplatArray;r&&(h=te.ProgressiveToSplatArray);const f=I.HeaderSizeBytes+I.SectionHeaderSizeBytes,p=Y.ProgressiveLoadSectionSize,A=1;let C,g,x,B=0,y=0,E;const S=Kt();let w=0,F=0,b=[];const D=(M,L,R,O)=>{const k=M>=100;if(R&&b.push(R),h===te.DownloadBeforeProcessing){k&&S.resolve(b);return}if(!O){if(t)throw new wt("Cannon directly load .splat because no file size info is available.");h=te.DownloadBeforeProcessing;return}if(!C){B=O/j.RowSizeBytes,C=new ArrayBuffer(O);const U=I.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat,_=f+U*B;h===te.ProgressiveToSplatBuffer?(g=new ArrayBuffer(_),I.writeHeaderToBuffer({versionMajor:I.CurrentMajorVersion,versionMinor:I.CurrentMinorVersion,maxSectionCount:A,sectionCount:A,maxSplatCount:B,splatCount:y,compressionLevel:0,sceneCenter:new v},g)):E=new P(0)}if(R){new Uint8Array(C,F,R.byteLength).set(new Uint8Array(R)),F+=R.byteLength;const U=F-w;if(U>p||k){const H=(k?U:p)/j.RowSizeBytes,Q=y+H;h===te.ProgressiveToSplatBuffer?j.parseToUncompressedSplatBufferSection(y,Q-1,C,0,g,f):j.parseToUncompressedSplatArraySection(y,Q-1,C,0,E),y=Q,h===te.ProgressiveToSplatBuffer&&(x||(I.writeSectionHeaderToBuffer({maxSplatCount:B,splatCount:y,bucketSize:0,bucketCount:0,bucketBlockSize:0,compressionScaleRange:0,storageSizeBytes:0,fullBucketCount:0,partiallyFilledBucketCount:0},0,g,I.HeaderSizeBytes),x=new I(g,!1)),x.updateLoadedCounts(1,y),n&&n(x,k)),w+=p}}k&&(h===te.ProgressiveToSplatBuffer?S.resolve(x):S.resolve(E)),s&&s(M,L,ue.Downloading)};return s&&s(0,"0%",ue.Downloading),Dt(e,D,!1,a).then(()=>(s&&s(0,"0%",ue.Processing),S.promise.then(M=>(s&&s(100,"100%",ue.Done),h===te.DownloadBeforeProcessing?new Blob(b).arrayBuffer().then(L=>is.loadFromFileData(L,o,i,r,l,c,d,u)):h===te.ProgressiveToSplatBuffer?M:ve(()=>zs(M,r,o,i,l,c,d,u))))))}static loadFromFileData(e,s,t,n,o,i,r,a){return ve(()=>{const l=j.parseStandardSplatToUncompressedSplatArray(e);return zs(l,n,s,t,o,i,r,a)})}}class lt{static checkVersion(e){const s=I.CurrentMajorVersion,t=I.CurrentMinorVersion,n=I.parseHeader(e);if(n.versionMajor===s&&n.versionMinor>=t||n.versionMajor>s)return!0;throw new Error(`KSplat version not supported: v${n.versionMajor}.${n.versionMinor}. Minimum required: v${s}.${t}`)}static loadFromURL(e,s,t,n,o){let i,r,a,l,c=!1,d=!1,u,h=[],f=!1,p=!1,A=0,C=0,g=0,x=!1,B=!1,y=!1,E=[];const S=Kt(),w=()=>{!c&&!d&&A>=I.HeaderSizeBytes&&(d=!0,new Blob(E).arrayBuffer().then(O=>{a=new ArrayBuffer(I.HeaderSizeBytes),new Uint8Array(a).set(new Uint8Array(O,0,I.HeaderSizeBytes)),lt.checkVersion(a),d=!1,c=!0,l=I.parseHeader(a),window.setTimeout(()=>{D()},1)}))};let F=0;const b=()=>{F===0&&(F++,window.setTimeout(()=>{F--,M()},1))},D=()=>{const R=()=>{p=!0,new Blob(E).arrayBuffer().then(k=>{p=!1,f=!0,u=new ArrayBuffer(l.maxSectionCount*I.SectionHeaderSizeBytes),new Uint8Array(u).set(new Uint8Array(k,I.HeaderSizeBytes,l.maxSectionCount*I.SectionHeaderSizeBytes)),h=I.parseSectionHeaders(l,u,0,!1);let U=0;for(let H=0;H<l.maxSectionCount;H++)U+=h[H].storageSizeBytes;const _=I.HeaderSizeBytes+l.maxSectionCount*I.SectionHeaderSizeBytes+U;if(!i){i=new ArrayBuffer(_);let H=0;for(let Q=0;Q<E.length;Q++){const ee=E[Q];new Uint8Array(i,H,ee.byteLength).set(new Uint8Array(ee)),H+=ee.byteLength}}g=I.HeaderSizeBytes+I.SectionHeaderSizeBytes*l.maxSectionCount;for(let H=0;H<=h.length&&H<l.maxSectionCount;H++)g+=h[H].storageSizeBytes;b()})};!p&&!f&&c&&A>=I.HeaderSizeBytes+I.SectionHeaderSizeBytes*l.maxSectionCount&&R()},M=()=>{if(y)return;y=!0;const R=()=>{if(y=!1,f){if(B)return;if(x=A>=g,A-C>Y.ProgressiveLoadSectionSize||x){C+=Y.ProgressiveLoadSectionSize,B=C>=g,r||(r=new I(i,!1));const k=I.HeaderSizeBytes+I.SectionHeaderSizeBytes*l.maxSectionCount;let U=0,_=0,H=0;for(let le=0;le<l.maxSectionCount;le++){const V=h[le],se=U+V.partiallyFilledBucketCount*4+V.bucketStorageSizeBytes*V.bucketCount,Z=k+se;if(C>=Z){_++;const G=C-Z,de=I.CompressionLevels[l.compressionLevel].SphericalHarmonicsDegrees[V.sphericalHarmonicsDegree].BytesPerSplat;let ie=Math.floor(G/de);ie=Math.min(ie,V.maxSplatCount),H+=ie,r.updateLoadedCounts(_,H),r.updateSectionLoadedCounts(le,ie)}else break;U+=V.storageSizeBytes}n(r,B);const Q=C/g*100,ee=Q.toFixed(2)+"%";s&&s(Q,ee,ue.Downloading),B?S.resolve(r):M()}}};window.setTimeout(R,Y.ProgressiveLoadSectionDelayDuration)};return Dt(e,(R,O,k)=>{k&&(E.push(k),i&&new Uint8Array(i,A,k.byteLength).set(new Uint8Array(k)),A+=k.byteLength),t?(w(),D(),M()):s&&s(R,O,ue.Downloading)},!t,o).then(R=>(s&&s(0,"0%",ue.Processing),(t?S.promise:lt.loadFromFileData(R)).then(k=>(s&&s(100,"100%",ue.Done),k))))}static loadFromFileData(e){return ve(()=>(lt.checkVersion(e),new I(e)))}static downloadFile=(function(){let e;return function(s,t){const n=new Blob([s.bufferData],{type:"application/octet-stream"});e||(e=document.createElement("a"),document.body.appendChild(e)),e.download=t,e.href=URL.createObjectURL(n),e.click()}})()}const Te={Splat:0,KSplat:1,Ply:2,Spz:3},_s=m=>m.endsWith(".ply")?Te.Ply:m.endsWith(".splat")?Te.Splat:m.endsWith(".ksplat")?Te.KSplat:m.endsWith(".spz")?Te.Spz:null,Qs={type:"change"},Ut={type:"start"},Ns={type:"end"},xt=new bn,Vs=new Rn,Lo=Math.cos(70*Zs.DEG2RAD);class It extends Dn{constructor(e,s){super(),this.object=e,this.domElement=s,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new v,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"KeyA",UP:"KeyW",RIGHT:"KeyD",BOTTOM:"KeyS"},this.mouseButtons={LEFT:Ge.ROTATE,MIDDLE:Ge.DOLLY,RIGHT:Ge.PAN},this.touches={ONE:qe.ROTATE,TWO:qe.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return r.phi},this.getAzimuthalAngle=function(){return r.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(T){T.addEventListener("keydown",bt),this._domElementKeyEvents=T},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",bt),this._domElementKeyEvents=null},this.saveState=function(){t.target0.copy(t.target),t.position0.copy(t.object.position),t.zoom0=t.object.zoom},this.reset=function(){t.target.copy(t.target0),t.object.position.copy(t.position0),t.object.zoom=t.zoom0,this.clearDampedRotation(),this.clearDampedPan(),t.object.updateProjectionMatrix(),t.dispatchEvent(Qs),t.update(),o=n.NONE},this.clearDampedRotation=function(){a.theta=0,a.phi=0},this.clearDampedPan=function(){c.set(0,0,0)},this.update=(function(){const T=new v,z=new ge().setFromUnitVectors(e.up,new v(0,1,0)),he=z.clone().invert(),me=new v,Ee=new ge,Ve=new v,He=2*Math.PI;return function(){z.setFromUnitVectors(e.up,new v(0,1,0)),he.copy(z).invert();const ps=t.object.position;T.copy(ps).sub(t.target),T.applyQuaternion(z),r.setFromVector3(T),t.autoRotate&&o===n.NONE&&D(F()),t.enableDamping?(r.theta+=a.theta*t.dampingFactor,r.phi+=a.phi*t.dampingFactor):(r.theta+=a.theta,r.phi+=a.phi);let Me=t.minAzimuthAngle,Pe=t.maxAzimuthAngle;isFinite(Me)&&isFinite(Pe)&&(Me<-Math.PI?Me+=He:Me>Math.PI&&(Me-=He),Pe<-Math.PI?Pe+=He:Pe>Math.PI&&(Pe-=He),Me<=Pe?r.theta=Math.max(Me,Math.min(Pe,r.theta)):r.theta=r.theta>(Me+Pe)/2?Math.max(Me,r.theta):Math.min(Pe,r.theta)),r.phi=Math.max(t.minPolarAngle,Math.min(t.maxPolarAngle,r.phi)),r.makeSafe(),t.enableDamping===!0?t.target.addScaledVector(c,t.dampingFactor):t.target.add(c),t.zoomToCursor&&E||t.object.isOrthographicCamera?r.radius=H(r.radius):r.radius=H(r.radius*l),T.setFromSpherical(r),T.applyQuaternion(he),ps.copy(t.target).add(T),t.object.lookAt(t.target),t.enableDamping===!0?(a.theta*=1-t.dampingFactor,a.phi*=1-t.dampingFactor,c.multiplyScalar(1-t.dampingFactor)):(a.set(0,0,0),c.set(0,0,0));let mt=!1;if(t.zoomToCursor&&E){let tt=null;if(t.object.isPerspectiveCamera){const st=T.length();tt=H(st*l);const At=st-tt;t.object.position.addScaledVector(B,At),t.object.updateMatrixWorld()}else if(t.object.isOrthographicCamera){const st=new v(y.x,y.y,0);st.unproject(t.object),t.object.zoom=Math.max(t.minZoom,Math.min(t.maxZoom,t.object.zoom/l)),t.object.updateProjectionMatrix(),mt=!0;const At=new v(y.x,y.y,0);At.unproject(t.object),t.object.position.sub(At).add(st),t.object.updateMatrixWorld(),tt=T.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),t.zoomToCursor=!1;tt!==null&&(this.screenSpacePanning?t.target.set(0,0,-1).transformDirection(t.object.matrix).multiplyScalar(tt).add(t.object.position):(xt.origin.copy(t.object.position),xt.direction.set(0,0,-1).transformDirection(t.object.matrix),Math.abs(t.object.up.dot(xt.direction))<Lo?e.lookAt(t.target):(Vs.setFromNormalAndCoplanarPoint(t.object.up,t.target),xt.intersectPlane(Vs,t.target))))}else t.object.isOrthographicCamera&&(t.object.zoom=Math.max(t.minZoom,Math.min(t.maxZoom,t.object.zoom/l)),t.object.updateProjectionMatrix(),mt=!0);return l=1,E=!1,mt||me.distanceToSquared(t.object.position)>i||8*(1-Ee.dot(t.object.quaternion))>i||Ve.distanceToSquared(t.target)>0?(t.dispatchEvent(Qs),me.copy(t.object.position),Ee.copy(t.object.quaternion),Ve.copy(t.target),mt=!1,!0):!1}})(),this.dispose=function(){t.domElement.removeEventListener("contextmenu",hs),t.domElement.removeEventListener("pointerdown",Ce),t.domElement.removeEventListener("pointercancel",ke),t.domElement.removeEventListener("wheel",ds),t.domElement.removeEventListener("pointermove",Be),t.domElement.removeEventListener("pointerup",ke),t._domElementKeyEvents!==null&&(t._domElementKeyEvents.removeEventListener("keydown",bt),t._domElementKeyEvents=null)};const t=this,n={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let o=n.NONE;const i=1e-6,r=new ys,a=new ys;let l=1;const c=new v,d=new N,u=new N,h=new N,f=new N,p=new N,A=new N,C=new N,g=new N,x=new N,B=new v,y=new N;let E=!1;const S=[],w={};function F(){return 2*Math.PI/60/60*t.autoRotateSpeed}function b(){return Math.pow(.95,t.zoomSpeed)}function D(T){a.theta-=T}function M(T){a.phi-=T}const L=(function(){const T=new v;return function(he,me){T.setFromMatrixColumn(me,0),T.multiplyScalar(-he),c.add(T)}})(),R=(function(){const T=new v;return function(he,me){t.screenSpacePanning===!0?T.setFromMatrixColumn(me,1):(T.setFromMatrixColumn(me,0),T.crossVectors(t.object.up,T)),T.multiplyScalar(he),c.add(T)}})(),O=(function(){const T=new v;return function(he,me){const Ee=t.domElement;if(t.object.isPerspectiveCamera){const Ve=t.object.position;T.copy(Ve).sub(t.target);let He=T.length();He*=Math.tan(t.object.fov/2*Math.PI/180),L(2*he*He/Ee.clientHeight,t.object.matrix),R(2*me*He/Ee.clientHeight,t.object.matrix)}else t.object.isOrthographicCamera?(L(he*(t.object.right-t.object.left)/t.object.zoom/Ee.clientWidth,t.object.matrix),R(me*(t.object.top-t.object.bottom)/t.object.zoom/Ee.clientHeight,t.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),t.enablePan=!1)}})();function k(T){t.object.isPerspectiveCamera||t.object.isOrthographicCamera?l/=T:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),t.enableZoom=!1)}function U(T){t.object.isPerspectiveCamera||t.object.isOrthographicCamera?l*=T:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),t.enableZoom=!1)}function _(T){if(!t.zoomToCursor)return;E=!0;const z=t.domElement.getBoundingClientRect(),he=T.clientX-z.left,me=T.clientY-z.top,Ee=z.width,Ve=z.height;y.x=he/Ee*2-1,y.y=-(me/Ve)*2+1,B.set(y.x,y.y,1).unproject(e).sub(e.position).normalize()}function H(T){return Math.max(t.minDistance,Math.min(t.maxDistance,T))}function Q(T){d.set(T.clientX,T.clientY)}function ee(T){_(T),C.set(T.clientX,T.clientY)}function le(T){f.set(T.clientX,T.clientY)}function V(T){u.set(T.clientX,T.clientY),h.subVectors(u,d).multiplyScalar(t.rotateSpeed);const z=t.domElement;D(2*Math.PI*h.x/z.clientHeight),M(2*Math.PI*h.y/z.clientHeight),d.copy(u),t.update()}function se(T){g.set(T.clientX,T.clientY),x.subVectors(g,C),x.y>0?k(b()):x.y<0&&U(b()),C.copy(g),t.update()}function Z(T){p.set(T.clientX,T.clientY),A.subVectors(p,f).multiplyScalar(t.panSpeed),O(A.x,A.y),f.copy(p),t.update()}function G(T){_(T),T.deltaY<0?U(b()):T.deltaY>0&&k(b()),t.update()}function X(T){let z=!1;switch(T.code){case t.keys.UP:T.ctrlKey||T.metaKey||T.shiftKey?M(2*Math.PI*t.rotateSpeed/t.domElement.clientHeight):O(0,t.keyPanSpeed),z=!0;break;case t.keys.BOTTOM:T.ctrlKey||T.metaKey||T.shiftKey?M(-2*Math.PI*t.rotateSpeed/t.domElement.clientHeight):O(0,-t.keyPanSpeed),z=!0;break;case t.keys.LEFT:T.ctrlKey||T.metaKey||T.shiftKey?D(2*Math.PI*t.rotateSpeed/t.domElement.clientHeight):O(t.keyPanSpeed,0),z=!0;break;case t.keys.RIGHT:T.ctrlKey||T.metaKey||T.shiftKey?D(-2*Math.PI*t.rotateSpeed/t.domElement.clientHeight):O(-t.keyPanSpeed,0),z=!0;break}z&&(T.preventDefault(),t.update())}function ce(){if(S.length===1)d.set(S[0].pageX,S[0].pageY);else{const T=.5*(S[0].pageX+S[1].pageX),z=.5*(S[0].pageY+S[1].pageY);d.set(T,z)}}function de(){if(S.length===1)f.set(S[0].pageX,S[0].pageY);else{const T=.5*(S[0].pageX+S[1].pageX),z=.5*(S[0].pageY+S[1].pageY);f.set(T,z)}}function ie(){const T=S[0].pageX-S[1].pageX,z=S[0].pageY-S[1].pageY,he=Math.sqrt(T*T+z*z);C.set(0,he)}function Se(){t.enableZoom&&ie(),t.enablePan&&de()}function pe(){t.enableZoom&&ie(),t.enableRotate&&ce()}function ne(T){if(S.length==1)u.set(T.pageX,T.pageY);else{const he=Rt(T),me=.5*(T.pageX+he.x),Ee=.5*(T.pageY+he.y);u.set(me,Ee)}h.subVectors(u,d).multiplyScalar(t.rotateSpeed);const z=t.domElement;D(2*Math.PI*h.x/z.clientHeight),M(2*Math.PI*h.y/z.clientHeight),d.copy(u)}function fe(T){if(S.length===1)p.set(T.pageX,T.pageY);else{const z=Rt(T),he=.5*(T.pageX+z.x),me=.5*(T.pageY+z.y);p.set(he,me)}A.subVectors(p,f).multiplyScalar(t.panSpeed),O(A.x,A.y),f.copy(p)}function $(T){const z=Rt(T),he=T.pageX-z.x,me=T.pageY-z.y,Ee=Math.sqrt(he*he+me*me);g.set(0,Ee),x.set(0,Math.pow(g.y/C.y,t.zoomSpeed)),k(x.y),C.copy(g)}function Fe(T){t.enableZoom&&$(T),t.enablePan&&fe(T)}function be(T){t.enableZoom&&$(T),t.enableRotate&&ne(T)}function Ce(T){t.enabled!==!1&&(S.length===0&&(t.domElement.setPointerCapture(T.pointerId),t.domElement.addEventListener("pointermove",Be),t.domElement.addEventListener("pointerup",ke)),fn(T),T.pointerType==="touch"?un(T):dn(T))}function Be(T){t.enabled!==!1&&(T.pointerType==="touch"?pn(T):hn(T))}function ke(T){mn(T),S.length===0&&(t.domElement.releasePointerCapture(T.pointerId),t.domElement.removeEventListener("pointermove",Be),t.domElement.removeEventListener("pointerup",ke)),t.dispatchEvent(Ns),o=n.NONE}function dn(T){let z;switch(T.button){case 0:z=t.mouseButtons.LEFT;break;case 1:z=t.mouseButtons.MIDDLE;break;case 2:z=t.mouseButtons.RIGHT;break;default:z=-1}switch(z){case Ge.DOLLY:if(t.enableZoom===!1)return;ee(T),o=n.DOLLY;break;case Ge.ROTATE:if(T.ctrlKey||T.metaKey||T.shiftKey){if(t.enablePan===!1)return;le(T),o=n.PAN}else{if(t.enableRotate===!1)return;Q(T),o=n.ROTATE}break;case Ge.PAN:if(T.ctrlKey||T.metaKey||T.shiftKey){if(t.enableRotate===!1)return;Q(T),o=n.ROTATE}else{if(t.enablePan===!1)return;le(T),o=n.PAN}break;default:o=n.NONE}o!==n.NONE&&t.dispatchEvent(Ut)}function hn(T){switch(o){case n.ROTATE:if(t.enableRotate===!1)return;V(T);break;case n.DOLLY:if(t.enableZoom===!1)return;se(T);break;case n.PAN:if(t.enablePan===!1)return;Z(T);break}}function ds(T){t.enabled===!1||t.enableZoom===!1||o!==n.NONE||(T.preventDefault(),t.dispatchEvent(Ut),G(T),t.dispatchEvent(Ns))}function bt(T){t.enabled===!1||t.enablePan===!1||X(T)}function un(T){switch(us(T),S.length){case 1:switch(t.touches.ONE){case qe.ROTATE:if(t.enableRotate===!1)return;ce(),o=n.TOUCH_ROTATE;break;case qe.PAN:if(t.enablePan===!1)return;de(),o=n.TOUCH_PAN;break;default:o=n.NONE}break;case 2:switch(t.touches.TWO){case qe.DOLLY_PAN:if(t.enableZoom===!1&&t.enablePan===!1)return;Se(),o=n.TOUCH_DOLLY_PAN;break;case qe.DOLLY_ROTATE:if(t.enableZoom===!1&&t.enableRotate===!1)return;pe(),o=n.TOUCH_DOLLY_ROTATE;break;default:o=n.NONE}break;default:o=n.NONE}o!==n.NONE&&t.dispatchEvent(Ut)}function pn(T){switch(us(T),o){case n.TOUCH_ROTATE:if(t.enableRotate===!1)return;ne(T),t.update();break;case n.TOUCH_PAN:if(t.enablePan===!1)return;fe(T),t.update();break;case n.TOUCH_DOLLY_PAN:if(t.enableZoom===!1&&t.enablePan===!1)return;Fe(T),t.update();break;case n.TOUCH_DOLLY_ROTATE:if(t.enableZoom===!1&&t.enableRotate===!1)return;be(T),t.update();break;default:o=n.NONE}}function hs(T){t.enabled!==!1&&T.preventDefault()}function fn(T){S.push(T)}function mn(T){delete w[T.pointerId];for(let z=0;z<S.length;z++)if(S[z].pointerId==T.pointerId){S.splice(z,1);return}}function us(T){let z=w[T.pointerId];z===void 0&&(z=new N,w[T.pointerId]=z),z.set(T.pageX,T.pageY)}function Rt(T){const z=T.pointerId===S[0].pointerId?S[1]:S[0];return w[z.pointerId]}t.domElement.addEventListener("contextmenu",hs),t.domElement.addEventListener("pointerdown",Ce),t.domElement.addEventListener("pointercancel",ke),t.domElement.addEventListener("wheel",ds,{passive:!1}),this.update()}}const ko=(m,e,s,t,n)=>{const o=performance.now();let i=m.style.display==="none"?0:parseFloat(m.style.opacity);isNaN(i)&&(i=1);const r=window.setInterval(()=>{const l=performance.now()-o;let c=Math.min(l/t,1);c>.999&&(c=1);let d;e?(d=(1-c)*i,d<1e-4&&(d=0)):d=(1-i)*c+i,d>0?(m.style.display=s,m.style.opacity=d):m.style.display="none",c>=1&&(n&&n(),window.clearInterval(r))},16);return r},Ho=500;class as{static elementIDGen=0;constructor(e,s){this.taskIDGen=0,this.elementID=as.elementIDGen++,this.tasks=[],this.message=e||"Loading...",this.container=s||document.body,this.spinnerContainerOuter=document.createElement("div"),this.spinnerContainerOuter.className=`spinnerOuterContainer${this.elementID}`,this.spinnerContainerOuter.style.display="none",this.spinnerContainerPrimary=document.createElement("div"),this.spinnerContainerPrimary.className=`spinnerContainerPrimary${this.elementID}`,this.spinnerPrimary=document.createElement("div"),this.spinnerPrimary.classList.add(`spinner${this.elementID}`,`spinnerPrimary${this.elementID}`),this.messageContainerPrimary=document.createElement("div"),this.messageContainerPrimary.classList.add(`messageContainer${this.elementID}`,`messageContainerPrimary${this.elementID}`),this.messageContainerPrimary.innerHTML=this.message,this.spinnerContainerMin=document.createElement("div"),this.spinnerContainerMin.className=`spinnerContainerMin${this.elementID}`,this.spinnerMin=document.createElement("div"),this.spinnerMin.classList.add(`spinner${this.elementID}`,`spinnerMin${this.elementID}`),this.messageContainerMin=document.createElement("div"),this.messageContainerMin.classList.add(`messageContainer${this.elementID}`,`messageContainerMin${this.elementID}`),this.messageContainerMin.innerHTML=this.message,this.spinnerContainerPrimary.appendChild(this.spinnerPrimary),this.spinnerContainerPrimary.appendChild(this.messageContainerPrimary),this.spinnerContainerOuter.appendChild(this.spinnerContainerPrimary),this.spinnerContainerMin.appendChild(this.spinnerMin),this.spinnerContainerMin.appendChild(this.messageContainerMin),this.spinnerContainerOuter.appendChild(this.spinnerContainerMin);const t=document.createElement("style");t.innerHTML=`

            .spinnerOuterContainer${this.elementID} {
                width: 100%;
                height: 100%;
                margin: 0;
                top: 0;
                left: 0;
                position: absolute;
                pointer-events: none;
            }

            .messageContainer${this.elementID} {
                height: 20px;
                font-family: arial;
                font-size: 12pt;
                color: #ffffff;
                text-align: center;
                vertical-align: middle;
            }

            .spinner${this.elementID} {
                padding: 15px;
                background: #07e8d6;
                z-index:99999;
            
                aspect-ratio: 1;
                border-radius: 50%;
                --_m: 
                    conic-gradient(#0000,#000),
                    linear-gradient(#000 0 0) content-box;
                -webkit-mask: var(--_m);
                    mask: var(--_m);
                -webkit-mask-composite: source-out;
                    mask-composite: subtract;
                box-sizing: border-box;
                animation: load 1s linear infinite;
            }

            .spinnerContainerPrimary${this.elementID} {
                z-index:99999;
                background-color: rgba(128, 128, 128, 0.75);
                border: #666666 1px solid;
                border-radius: 5px;
                padding-top: 20px;
                padding-bottom: 10px;
                margin: 0;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-80px, -80px);
                width: 180px;
                pointer-events: auto;
            }

            .spinnerPrimary${this.elementID} {
                width: 120px;
                margin-left: 30px;
            }

            .messageContainerPrimary${this.elementID} {
                padding-top: 15px;
            }

            .spinnerContainerMin${this.elementID} {
                z-index:99999;
                background-color: rgba(128, 128, 128, 0.75);
                border: #666666 1px solid;
                border-radius: 5px;
                padding-top: 20px;
                padding-bottom: 15px;
                margin: 0;
                position: absolute;
                bottom: 50px;
                left: 50%;
                transform: translate(-50%, 0);
                display: flex;
                flex-direction: left;
                pointer-events: auto;
                min-width: 250px;
            }

            .messageContainerMin${this.elementID} {
                margin-right: 15px;
            }

            .spinnerMin${this.elementID} {
                width: 50px;
                height: 50px;
                margin-left: 15px;
                margin-right: 25px;
            }

            .messageContainerMin${this.elementID} {
                padding-top: 15px;
            }
            
            @keyframes load {
                to{transform: rotate(1turn)}
            }

        `,this.spinnerContainerOuter.appendChild(t),this.container.appendChild(this.spinnerContainerOuter),this.setMinimized(!1,!0),this.fadeTransitions=[]}addTask(e){const s={message:e,id:this.taskIDGen++};return this.tasks.push(s),this.update(),s.id}removeTask(e){let s=0;for(let t of this.tasks){if(t.id===e){this.tasks.splice(s,1);break}s++}this.update()}removeAllTasks(){this.tasks=[],this.update()}setMessageForTask(e,s){for(let t of this.tasks)if(t.id===e){t.message=s;break}this.update()}update(){this.tasks.length>0?(this.show(),this.setMessage(this.tasks[this.tasks.length-1].message)):this.hide()}show(){this.spinnerContainerOuter.style.display="block",this.visible=!0}hide(){this.spinnerContainerOuter.style.display="none",this.visible=!1}setContainer(e){this.container&&this.spinnerContainerOuter.parentElement===this.container&&this.container.removeChild(this.spinnerContainerOuter),e&&(this.container=e,this.container.appendChild(this.spinnerContainerOuter),this.spinnerContainerOuter.style.zIndex=this.container.style.zIndex+1)}setMinimized(e,s){const t=(n,o,i,r,a)=>{i?n.style.display=o?r:"none":this.fadeTransitions[a]=ko(n,!o,r,Ho,()=>{this.fadeTransitions[a]=null})};t(this.spinnerContainerPrimary,!e,s,"block",0),t(this.spinnerContainerMin,e,s,"flex",1),this.minimized=e}setMessage(e){this.messageContainerPrimary.innerHTML=e,this.messageContainerMin.innerHTML=e}}class Uo{constructor(e){this.idGen=0,this.tasks=[],this.container=e||document.body,this.progressBarContainerOuter=document.createElement("div"),this.progressBarContainerOuter.className="progressBarOuterContainer",this.progressBarContainerOuter.style.display="none",this.progressBarBox=document.createElement("div"),this.progressBarBox.className="progressBarBox",this.progressBarBackground=document.createElement("div"),this.progressBarBackground.className="progressBarBackground",this.progressBar=document.createElement("div"),this.progressBar.className="progressBar",this.progressBarBackground.appendChild(this.progressBar),this.progressBarBox.appendChild(this.progressBarBackground),this.progressBarContainerOuter.appendChild(this.progressBarBox);const s=document.createElement("style");s.innerHTML=`

            .progressBarOuterContainer {
                width: 100%;
                height: 100%;
                margin: 0;
                top: 0;
                left: 0;
                position: absolute;
                pointer-events: none;
            }

            .progressBarBox {
                z-index:99999;
                padding: 7px 9px 5px 7px;
                background-color: rgba(190, 190, 190, 0.75);
                border: #555555 1px solid;
                border-radius: 15px;
                margin: 0;
                position: absolute;
                bottom: 50px;
                left: 50%;
                transform: translate(-50%, 0);
                width: 180px;
                height: 30px;
                pointer-events: auto;
            }

            .progressBarBackground {
                width: 100%;
                height: 25px;
                border-radius:10px;
                background-color: rgba(128, 128, 128, 0.75);
                border: #444444 1px solid;
                box-shadow: inset 0 0 10px #333333;
            }

            .progressBar {
                height: 25px;
                width: 0px;
                border-radius:10px;
                background-color: rgba(0, 200, 0, 0.75);
                box-shadow: inset 0 0 10px #003300;
            }

        `,this.progressBarContainerOuter.appendChild(s),this.container.appendChild(this.progressBarContainerOuter)}show(){this.progressBarContainerOuter.style.display="block"}hide(){this.progressBarContainerOuter.style.display="none"}setProgress(e){this.progressBar.style.width=e+"%"}setContainer(e){this.container&&this.progressBarContainerOuter.parentElement===this.container&&this.container.removeChild(this.progressBarContainerOuter),e&&(this.container=e,this.container.appendChild(this.progressBarContainerOuter),this.progressBarContainerOuter.style.zIndex=this.container.style.zIndex+1)}}class zo{constructor(e){this.container=e||document.body,this.infoCells={};const s=[["Camera position","cameraPosition"],["Camera look-at","cameraLookAt"],["Camera up","cameraUp"],["Camera mode","orthographicCamera"],["Cursor position","cursorPosition"],["FPS","fps"],["Rendering:","renderSplatCount"],["Sort time","sortTime"],["Render window","renderWindow"],["Focal adjustment","focalAdjustment"],["Splat scale","splatScale"],["Point cloud mode","pointCloudMode"]];this.infoPanelContainer=document.createElement("div");const t=document.createElement("style");t.innerHTML=`

            .infoPanel {
                width: 430px;
                padding: 10px;
                background-color: rgba(50, 50, 50, 0.85);
                border: #555555 2px solid;
                color: #dddddd;
                border-radius: 10px;
                z-index: 9999;
                font-family: arial;
                font-size: 11pt;
                text-align: left;
                margin: 0;
                top: 10px;
                left:10px;
                position: absolute;
                pointer-events: auto;
            }

            .info-panel-cell {
                margin-bottom: 5px;
                padding-bottom: 2px;
            }

            .label-cell {
                font-weight: bold;
                font-size: 12pt;
                width: 140px;
            }

        `,this.infoPanelContainer.append(t),this.infoPanel=document.createElement("div"),this.infoPanel.className="infoPanel";const n=document.createElement("div");n.style.display="table";for(let o of s){const i=document.createElement("div");i.style.display="table-row",i.className="info-panel-row";const r=document.createElement("div");r.style.display="table-cell",r.innerHTML=`${o[0]}: `,r.classList.add("info-panel-cell","label-cell");const a=document.createElement("div");a.style.display="table-cell",a.style.width="10px",a.innerHTML=" ",a.className="info-panel-cell";const l=document.createElement("div");l.style.display="table-cell",l.innerHTML="",l.className="info-panel-cell",this.infoCells[o[1]]=l,i.appendChild(r),i.appendChild(a),i.appendChild(l),n.appendChild(i)}this.infoPanel.appendChild(n),this.infoPanelContainer.append(this.infoPanel),this.infoPanelContainer.style.display="none",this.container.appendChild(this.infoPanelContainer),this.visible=!1}update=function(e,s,t,n,o,i,r,a,l,c,d,u,h,f){const p=`${s.x.toFixed(5)}, ${s.y.toFixed(5)}, ${s.z.toFixed(5)}`;if(this.infoCells.cameraPosition.innerHTML!==p&&(this.infoCells.cameraPosition.innerHTML=p),t){const C=t,g=`${C.x.toFixed(5)}, ${C.y.toFixed(5)}, ${C.z.toFixed(5)}`;this.infoCells.cameraLookAt.innerHTML!==g&&(this.infoCells.cameraLookAt.innerHTML=g)}const A=`${n.x.toFixed(5)}, ${n.y.toFixed(5)}, ${n.z.toFixed(5)}`;if(this.infoCells.cameraUp.innerHTML!==A&&(this.infoCells.cameraUp.innerHTML=A),this.infoCells.orthographicCamera.innerHTML=o?"Orthographic":"Perspective",i){const C=i,g=`${C.x.toFixed(5)}, ${C.y.toFixed(5)}, ${C.z.toFixed(5)}`;this.infoCells.cursorPosition.innerHTML=g}else this.infoCells.cursorPosition.innerHTML="N/A";this.infoCells.fps.innerHTML=r,this.infoCells.renderWindow.innerHTML=`${e.x} x ${e.y}`,this.infoCells.renderSplatCount.innerHTML=`${l} splats out of ${a} (${c.toFixed(2)}%)`,this.infoCells.sortTime.innerHTML=`${d.toFixed(3)} ms`,this.infoCells.focalAdjustment.innerHTML=`${u.toFixed(3)}`,this.infoCells.splatScale.innerHTML=`${h.toFixed(3)}`,this.infoCells.pointCloudMode.innerHTML=`${f}`};setContainer(e){this.container&&this.infoPanelContainer.parentElement===this.container&&this.container.removeChild(this.infoPanelContainer),e&&(this.container=e,this.container.appendChild(this.infoPanelContainer),this.infoPanelContainer.style.zIndex=this.container.style.zIndex+1)}show(){this.infoPanelContainer.style.display="block",this.visible=!0}hide(){this.infoPanelContainer.style.display="none",this.visible=!1}}const Gs=new v;class _o extends Xe{constructor(e=new v(0,0,1),s=new v(0,0,0),t=1,n=.1,o=16776960,i=t*.2,r=i*.2){super(),this.type="ArrowHelper";const a=new xs(n,n,t,32);a.translate(0,t/2,0);const l=new xs(0,r,i,32);l.translate(0,t,0),this.position.copy(s),this.line=new De(a,new pt({color:o,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new De(l,new pt({color:o,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{Gs.set(e.z,0,-e.x).normalize();const s=Math.acos(e.y);this.quaternion.setFromAxisAngle(Gs,s)}}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class ct{constructor(e){this.threeScene=e,this.splatRenderTarget=null,this.renderTargetCopyQuad=null,this.renderTargetCopyCamera=null,this.meshCursor=null,this.focusMarker=null,this.controlPlane=null,this.debugRoot=null,this.secondaryDebugRoot=null}updateSplatRenderTargetForRenderDimensions(e,s){this.destroySplatRendertarget(),this.splatRenderTarget=new Tn(e,s,{format:Bt,stencilBuffer:!1,depthBuffer:!0}),this.splatRenderTarget.depthTexture=new Bn(e,s),this.splatRenderTarget.depthTexture.format=En,this.splatRenderTarget.depthTexture.type=ot}destroySplatRendertarget(){this.splatRenderTarget&&(this.splatRenderTarget=null)}setupRenderTargetCopyObjects(){const e={sourceColorTexture:{type:"t",value:null},sourceDepthTexture:{type:"t",value:null}},s=new it({vertexShader:`
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4( position.xy, 0.0, 1.0 );    
                }
            `,fragmentShader:`
                #include <common>
                #include <packing>
                varying vec2 vUv;
                uniform sampler2D sourceColorTexture;
                uniform sampler2D sourceDepthTexture;
                void main() {
                    vec4 color = texture2D(sourceColorTexture, vUv);
                    float fragDepth = texture2D(sourceDepthTexture, vUv).x;
                    gl_FragDepth = fragDepth;
                    gl_FragColor = vec4(color.rgb, color.a * 2.0);
              }
            `,uniforms:e,depthWrite:!1,depthTest:!1,transparent:!0,blending:wn,blendSrc:As,blendSrcAlpha:As,blendDst:ms,blendDstAlpha:ms});s.extensions.fragDepth=!0,this.renderTargetCopyQuad=new De(new gs(2,2),s),this.renderTargetCopyCamera=new Js(-1,1,1,-1,0,1)}destroyRenderTargetCopyObjects(){this.renderTargetCopyQuad&&(Ye(this.renderTargetCopyQuad),this.renderTargetCopyQuad=null)}setupMeshCursor(){if(!this.meshCursor){const e=new vn(.5,1.5,32),s=new pt({color:16777215}),t=new De(e,s);t.rotation.set(0,0,Math.PI),t.position.set(0,1,0);const n=new De(e,s);n.position.set(0,-1,0);const o=new De(e,s);o.rotation.set(0,0,Math.PI/2),o.position.set(1,0,0);const i=new De(e,s);i.rotation.set(0,0,-Math.PI/2),i.position.set(-1,0,0),this.meshCursor=new Xe,this.meshCursor.add(t),this.meshCursor.add(n),this.meshCursor.add(o),this.meshCursor.add(i),this.meshCursor.scale.set(.1,.1,.1),this.threeScene.add(this.meshCursor),this.meshCursor.visible=!1}}destroyMeshCursor(){this.meshCursor&&(Ye(this.meshCursor),this.threeScene.remove(this.meshCursor),this.meshCursor=null)}setMeshCursorVisibility(e){this.meshCursor.visible=e}getMeschCursorVisibility(){return this.meshCursor.visible}setMeshCursorPosition(e){this.meshCursor.position.copy(e)}positionAndOrientMeshCursor(e,s){this.meshCursor.position.copy(e),this.meshCursor.up.copy(s.up),this.meshCursor.lookAt(s.position)}setupFocusMarker(){if(!this.focusMarker){const e=new Cs(.5,32,32),s=ct.buildFocusMarkerMaterial();s.depthTest=!1,s.depthWrite=!1,s.transparent=!0,this.focusMarker=new De(e,s)}}destroyFocusMarker(){this.focusMarker&&(Ye(this.focusMarker),this.focusMarker=null)}updateFocusMarker=(function(){const e=new v,s=new J,t=new v;return function(n,o,i){s.copy(o.matrixWorld).invert(),e.copy(n).applyMatrix4(s),e.normalize().multiplyScalar(10),e.applyMatrix4(o.matrixWorld),t.copy(o.position).sub(n);const r=t.length();this.focusMarker.position.copy(n),this.focusMarker.scale.set(r,r,r),this.focusMarker.material.uniforms.realFocusPosition.value.copy(n),this.focusMarker.material.uniforms.viewport.value.copy(i),this.focusMarker.material.uniformsNeedUpdate=!0}})();setFocusMarkerVisibility(e){this.focusMarker.visible=e}setFocusMarkerOpacity(e){this.focusMarker.material.uniforms.opacity.value=e,this.focusMarker.material.uniformsNeedUpdate=!0}getFocusMarkerOpacity(){return this.focusMarker.material.uniforms.opacity.value}setupControlPlane(){if(!this.controlPlane){const e=new gs(1,1);e.rotateX(-Math.PI/2);const s=new pt({color:16777215});s.transparent=!0,s.opacity=.6,s.depthTest=!1,s.depthWrite=!1,s.side=Wt;const t=new De(e,s),n=new v(0,1,0);n.normalize();const o=new v(0,0,0),i=.5,r=.01,a=56576,l=new _o(n,o,i,r,a,.1,.03);this.controlPlane=new Xe,this.controlPlane.add(t),this.controlPlane.add(l)}}destroyControlPlane(){this.controlPlane&&(Ye(this.controlPlane),this.controlPlane=null)}setControlPlaneVisibility(e){this.controlPlane.visible=e}positionAndOrientControlPlane=(function(){const e=new ge,s=new v(0,1,0);return function(t,n){e.setFromUnitVectors(s,n),this.controlPlane.position.copy(t),this.controlPlane.quaternion.copy(e)}})();addDebugMeshes(){this.debugRoot=this.createDebugMeshes(),this.secondaryDebugRoot=this.createSecondaryDebugMeshes(),this.threeScene.add(this.debugRoot),this.threeScene.add(this.secondaryDebugRoot)}destroyDebugMeshes(){for(let e of[this.debugRoot,this.secondaryDebugRoot])e&&(Ye(e),this.threeScene.remove(e));this.debugRoot=null,this.secondaryDebugRoot=null}createDebugMeshes(e){const s=new Cs(1,32,32),t=new Xe,n=(o,i)=>{let r=new De(s,ct.buildDebugMaterial(o));r.renderOrder=e,t.add(r),r.position.fromArray(i)};return n(16711680,[-50,0,0]),n(16711680,[50,0,0]),n(65280,[0,0,-50]),n(65280,[0,0,50]),n(16755200,[5,0,5]),t}createSecondaryDebugMeshes(e){const s=new Fn(3,3,3),t=new Xe;let n=12303291;const o=r=>{let a=new De(s,ct.buildDebugMaterial(n));a.renderOrder=e,t.add(a),a.position.fromArray(r)};let i=10;return o([-i,0,-i]),o([-i,0,i]),o([i,0,-i]),o([i,0,i]),t}static buildDebugMaterial(e){const s=`
            #include <common>
            varying float ndcDepth;

            void main() {
                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position.xyz, 1.0);
                ndcDepth = gl_Position.z / gl_Position.w;
                gl_Position.x = gl_Position.x / gl_Position.w;
                gl_Position.y = gl_Position.y / gl_Position.w;
                gl_Position.z = 0.0;
                gl_Position.w = 1.0;
    
            }
        `,t=`
            #include <common>
            uniform vec3 color;
            varying float ndcDepth;
            void main() {
                gl_FragDepth = (ndcDepth + 1.0) / 2.0;
                gl_FragColor = vec4(color.rgb, 0.0);
            }
        `,n={color:{type:"v3",value:new Et(e)}},o=new it({uniforms:n,vertexShader:s,fragmentShader:t,transparent:!1,depthTest:!0,depthWrite:!0,side:Ss});return o.extensions.fragDepth=!0,o}static buildFocusMarkerMaterial(e){const s=`
            #include <common>

            uniform vec2 viewport;
            uniform vec3 realFocusPosition;

            varying vec4 ndcPosition;
            varying vec4 ndcCenter;
            varying vec4 ndcFocusPosition;

            void main() {
                float radius = 0.01;

                vec4 viewPosition = modelViewMatrix * vec4(position.xyz, 1.0);
                vec4 viewCenter = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);

                vec4 viewFocusPosition = modelViewMatrix * vec4(realFocusPosition, 1.0);

                ndcPosition = projectionMatrix * viewPosition;
                ndcPosition = ndcPosition * vec4(1.0 / ndcPosition.w);
                ndcCenter = projectionMatrix * viewCenter;
                ndcCenter = ndcCenter * vec4(1.0 / ndcCenter.w);

                ndcFocusPosition = projectionMatrix * viewFocusPosition;
                ndcFocusPosition = ndcFocusPosition * vec4(1.0 / ndcFocusPosition.w);

                gl_Position = projectionMatrix * viewPosition;

            }
        `,t=`
            #include <common>
            uniform vec3 color;
            uniform vec2 viewport;
            uniform float opacity;

            varying vec4 ndcPosition;
            varying vec4 ndcCenter;
            varying vec4 ndcFocusPosition;

            void main() {
                vec2 screenPosition = vec2(ndcPosition) * viewport;
                vec2 screenCenter = vec2(ndcCenter) * viewport;

                vec2 screenVec = screenPosition - screenCenter;

                float projectedRadius = length(screenVec);

                float lineWidth = 0.0005 * viewport.y;
                float aaRange = 0.0025 * viewport.y;
                float radius = 0.06 * viewport.y;
                float radDiff = abs(projectedRadius - radius) - lineWidth;
                float alpha = 1.0 - clamp(radDiff / 5.0, 0.0, 1.0); 

                gl_FragColor = vec4(color.rgb, alpha * opacity);
            }
        `,n={color:{type:"v3",value:new Et(e)},realFocusPosition:{type:"v3",value:new v},viewport:{type:"v2",value:new N},opacity:{value:0}};return new it({uniforms:n,vertexShader:s,fragmentShader:t,transparent:!0,depthTest:!1,depthWrite:!1,side:Ss})}dispose(){this.destroyMeshCursor(),this.destroyFocusMarker(),this.destroyDebugMeshes(),this.destroyControlPlane(),this.destroyRenderTargetCopyObjects(),this.destroySplatRendertarget()}}const Qo=new v(1,0,0),No=new v(0,1,0),Vo=new v(0,0,1);class zt{constructor(e=new v,s=new v){this.origin=new v,this.direction=new v,this.setParameters(e,s)}setParameters(e,s){this.origin.copy(e),this.direction.copy(s).normalize()}boxContainsPoint(e,s,t){return!(s.x<e.min.x-t||s.x>e.max.x+t||s.y<e.min.y-t||s.y>e.max.y+t||s.z<e.min.z-t||s.z>e.max.z+t)}intersectBox=(function(){const e=new v,s=[],t=[],n=[];return function(o,i){if(t[0]=this.origin.x,t[1]=this.origin.y,t[2]=this.origin.z,n[0]=this.direction.x,n[1]=this.direction.y,n[2]=this.direction.z,this.boxContainsPoint(o,this.origin,1e-4))return i&&(i.origin.copy(this.origin),i.normal.set(0,0,0),i.distance=-1),!0;for(let r=0;r<3;r++){if(n[r]==0)continue;const a=r==0?Qo:r==1?No:Vo,l=n[r]<0?o.max:o.min;let c=-Math.sign(n[r]);s[0]=r==0?l.x:r==1?l.y:l.z;let d=s[0]-t[r];if(d*c<0){const u=(r+1)%3,h=(r+2)%3;if(s[2]=n[u]/n[r]*d+t[u],s[1]=n[h]/n[r]*d+t[h],e.set(s[r],s[h],s[u]),this.boxContainsPoint(o,e,1e-4))return i&&(i.origin.copy(e),i.normal.copy(a).multiplyScalar(c),i.distance=e.sub(this.origin).length()),!0}}return!1}})();intersectSphere=(function(){const e=new v;return function(s,t,n){e.copy(s).sub(this.origin);const o=e.dot(this.direction),i=o*o,a=e.dot(e)-i,l=t*t;if(a>l)return!1;const c=Math.sqrt(l-a),d=o-c,u=o+c;if(u<0)return!1;let h=d<0?u:d;return n&&(n.origin.copy(this.origin).addScaledVector(this.direction,h),n.normal.copy(n.origin).sub(s).normalize(),n.distance=h),!0}})()}class ls{constructor(){this.origin=new v,this.normal=new v,this.distance=0,this.splatIndex=0}set(e,s,t,n){this.origin.copy(e),this.normal.copy(s),this.distance=t,this.splatIndex=n}clone(){const e=new ls;return e.origin.copy(this.origin),e.normal.copy(this.normal),e.distance=this.distance,e.splatIndex=this.splatIndex,e}}const Le={ThreeD:0,TwoD:1};class Go{constructor(e,s,t=!1){this.ray=new zt(e,s),this.raycastAgainstTrueSplatEllipsoid=t}setFromCameraAndScreenPosition=(function(){const e=new N;return function(s,t,n){if(e.x=t.x/n.x*2-1,e.y=(n.y-t.y)/n.y*2-1,s.isPerspectiveCamera)this.ray.origin.setFromMatrixPosition(s.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(s).sub(this.ray.origin).normalize(),this.camera=s;else if(s.isOrthographicCamera)this.ray.origin.set(e.x,e.y,(s.near+s.far)/(s.near-s.far)).unproject(s),this.ray.direction.set(0,0,-1).transformDirection(s.matrixWorld),this.camera=s;else throw new Error("Raycaster::setFromCameraAndScreenPosition() -> Unsupported camera type")}})();intersectSplatMesh=(function(){const e=new J,s=new J,t=new J,n=new zt,o=new v;return function(i,r=[]){const a=i.getSplatTree();if(a){for(let l=0;l<a.subTrees.length;l++){const c=a.subTrees[l];s.copy(i.matrixWorld),i.dynamicMode&&(i.getSceneTransform(l,t),s.multiply(t)),e.copy(s).invert(),n.origin.copy(this.ray.origin).applyMatrix4(e),n.direction.copy(this.ray.origin).add(this.ray.direction),n.direction.applyMatrix4(e).sub(n.origin).normalize();const d=[];c.rootNode&&this.castRayAtSplatTreeNode(n,a,c.rootNode,d),d.forEach(u=>{u.origin.applyMatrix4(s),u.normal.applyMatrix4(s).normalize(),u.distance=o.copy(u.origin).sub(this.ray.origin).length()}),r.push(...d)}return r.sort((l,c)=>l.distance>c.distance?1:-1),r}}})();castRayAtSplatTreeNode=(function(){const e=new qt,s=new v,t=new v,n=new ge,o=new ls,i=1e-7,r=new v(0,0,0),a=new J,l=new J,c=new J,d=new J,u=new J,h=new zt;return function(f,p,A,C=[]){if(f.intersectBox(A.boundingBox)){if(A.data&&A.data.indexes&&A.data.indexes.length>0)for(let g=0;g<A.data.indexes.length;g++){const x=A.data.indexes[g],B=p.splatMesh.getSceneIndexForSplat(x);if(p.splatMesh.getScene(B).visible&&(p.splatMesh.getSplatColor(x,e),p.splatMesh.getSplatCenter(x,s),p.splatMesh.getSplatScaleAndRotation(x,t,n),!(t.x<=i||t.y<=i||p.splatMesh.splatRenderMode===Le.ThreeD&&t.z<=i)))if(this.raycastAgainstTrueSplatEllipsoid){l.makeScale(t.x,t.y,t.z),c.makeRotationFromQuaternion(n);const E=Math.log10(e.w)*2;if(a.makeScale(E,E,E),u.copy(a).multiply(c).multiply(l),d.copy(u).invert(),h.origin.copy(f.origin).sub(s).applyMatrix4(d),h.direction.copy(f.origin).add(f.direction).sub(s),h.direction.applyMatrix4(d).sub(h.origin).normalize(),h.intersectSphere(r,1,o)){const S=o.clone();S.splatIndex=x,S.origin.applyMatrix4(u).add(s),C.push(S)}}else{let E=t.x+t.y,S=2;if(p.splatMesh.splatRenderMode===Le.ThreeD&&(E+=t.z,S=3),E=E/S,f.intersectSphere(s,E,o)){const w=o.clone();w.splatIndex=x,C.push(w)}}}if(A.children&&A.children.length>0)for(let g of A.children)this.castRayAtSplatTreeNode(f,p,g,C);return C}}})()}class Ze{static buildVertexShaderBase(e=!1,s=!1,t=0,n=""){let o=`
        precision highp float;
        #include <common>

        attribute uint splatIndex;
        uniform highp usampler2D centersColorsTexture;
        uniform highp sampler2D sphericalHarmonicsTexture;
        uniform highp sampler2D sphericalHarmonicsTextureR;
        uniform highp sampler2D sphericalHarmonicsTextureG;
        uniform highp sampler2D sphericalHarmonicsTextureB;

        uniform highp usampler2D sceneIndexesTexture;
        uniform vec2 sceneIndexesTextureSize;
        uniform int sceneCount;
    `;return s&&(o+=`
            uniform float sceneOpacity[${Y.MaxScenes}];
            uniform int sceneVisibility[${Y.MaxScenes}];
        `),e&&(o+=`
            uniform highp mat4 transforms[${Y.MaxScenes}];
        `),o+=`
        ${n}
        uniform vec2 focal;
        uniform float orthoZoom;
        uniform int orthographicMode;
        uniform int pointCloudModeEnabled;
        uniform float inverseFocalAdjustment;
        uniform vec2 viewport;
        uniform vec2 basisViewport;
        uniform vec2 centersColorsTextureSize;
        uniform int sphericalHarmonicsDegree;
        uniform vec2 sphericalHarmonicsTextureSize;
        uniform int sphericalHarmonics8BitMode;
        uniform int sphericalHarmonicsMultiTextureMode;
        uniform float visibleRegionRadius;
        uniform float visibleRegionFadeStartRadius;
        uniform float firstRenderTime;
        uniform float currentTime;
        uniform int fadeInComplete;
        uniform vec3 sceneCenter;
        uniform float splatScale;
        uniform float sphericalHarmonics8BitCompressionRangeMin[${Y.MaxScenes}];
        uniform float sphericalHarmonics8BitCompressionRangeMax[${Y.MaxScenes}];

        varying vec4 vColor;
        varying vec2 vUv;
        varying vec2 vPosition;

        mat3 quaternionToRotationMatrix(float x, float y, float z, float w) {
            float s = 1.0 / sqrt(w * w + x * x + y * y + z * z);
        
            return mat3(
                1. - 2. * (y * y + z * z),
                2. * (x * y + w * z),
                2. * (x * z - w * y),
                2. * (x * y - w * z),
                1. - 2. * (x * x + z * z),
                2. * (y * z + w * x),
                2. * (x * z + w * y),
                2. * (y * z - w * x),
                1. - 2. * (x * x + y * y)
            );
        }

        const float sqrt8 = sqrt(8.0);
        const float minAlpha = 1.0 / 255.0;

        const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);
        const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));
        const uvec4 shift4 = uvec4(0, 8, 16, 24);
        vec4 uintToRGBAVec (uint u) {
           uvec4 urgba = mask4 & u;
           urgba = urgba >> shift4;
           vec4 rgba = vec4(urgba) * encodeNorm4;
           return rgba;
        }

        vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {
            vec2 samplerUV = vec2(0.0, 0.0);
            float d = float(splatIndex * uint(stride) + uint(offset)) / dimensions.x;
            samplerUV.y = float(floor(d)) / dimensions.y;
            samplerUV.x = fract(d);
            return samplerUV;
        }

        vec2 getDataUVF(in uint sIndex, in float stride, in uint offset, in vec2 dimensions) {
            vec2 samplerUV = vec2(0.0, 0.0);
            float d = float(uint(float(sIndex) * stride) + offset) / dimensions.x;
            samplerUV.y = float(floor(d)) / dimensions.y;
            samplerUV.x = fract(d);
            return samplerUV;
        }

        const float SH_C1 = 0.4886025119029199f;
        const float[5] SH_C2 = float[](1.0925484, -1.0925484, 0.3153916, -1.0925484, 0.5462742);

        void main () {

            uint oddOffset = splatIndex & uint(0x00000001);
            uint doubleOddOffset = oddOffset * uint(2);
            bool isEven = oddOffset == uint(0);
            uint nearestEvenIndex = splatIndex - oddOffset;
            float fOddOffset = float(oddOffset);

            uvec4 sampledCenterColor = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize));
            vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));

            uint sceneIndex = uint(0);
            if (sceneCount > 1) {
                sceneIndex = texture(sceneIndexesTexture, getDataUV(1, 0, sceneIndexesTextureSize)).r;
            }
            `,s&&(o+=`
                float splatOpacityFromScene = sceneOpacity[sceneIndex];
                int sceneVisible = sceneVisibility[sceneIndex];
                if (splatOpacityFromScene <= 0.01 || sceneVisible == 0) {
                    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);
                    return;
                }
            `),e?o+=`
                mat4 transform = transforms[sceneIndex];
                mat4 transformModelViewMatrix = viewMatrix * transform;
            `:o+="mat4 transformModelViewMatrix = modelViewMatrix;",o+=`
            float sh8BitCompressionRangeMinForScene = sphericalHarmonics8BitCompressionRangeMin[sceneIndex];
            float sh8BitCompressionRangeMaxForScene = sphericalHarmonics8BitCompressionRangeMax[sceneIndex];
            float sh8BitCompressionRangeForScene = sh8BitCompressionRangeMaxForScene - sh8BitCompressionRangeMinForScene;
            float sh8BitCompressionHalfRangeForScene = sh8BitCompressionRangeForScene / 2.0;
            vec3 vec8BitSHShift = vec3(sh8BitCompressionRangeMinForScene);

            vec4 viewCenter = transformModelViewMatrix * vec4(splatCenter, 1.0);

            vec4 clipCenter = projectionMatrix * viewCenter;

            float clip = 1.2 * clipCenter.w;
            if (clipCenter.z < -clip || clipCenter.x < -clip || clipCenter.x > clip || clipCenter.y < -clip || clipCenter.y > clip) {
                gl_Position = vec4(0.0, 0.0, 2.0, 1.0);
                return;
            }

            vec3 ndcCenter = clipCenter.xyz / clipCenter.w;

            vPosition = position.xy;
            vColor = uintToRGBAVec(sampledCenterColor.r);
        `,t>=1&&(o+=`   
            if (sphericalHarmonicsDegree >= 1) {
            `,e?o+=`
                    vec3 worldViewDir = normalize(splatCenter - vec3(inverse(transform) * vec4(cameraPosition, 1.0)));
                `:o+=`
                    vec3 worldViewDir = normalize(splatCenter - cameraPosition);
                `,o+=`
                vec3 sh1;
                vec3 sh2;
                vec3 sh3;
            `,t>=2&&(o+=`
                    vec3 sh4;
                    vec3 sh5;
                    vec3 sh6;
                    vec3 sh7;
                    vec3 sh8;
                `),t===1?o+=`
                    if (sphericalHarmonicsMultiTextureMode == 0) {
                        vec2 shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset, sphericalHarmonicsTextureSize);
                        vec4 sampledSH0123 = texture(sphericalHarmonicsTexture, shUV);
                        shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(1), sphericalHarmonicsTextureSize);
                        vec4 sampledSH4567 = texture(sphericalHarmonicsTexture, shUV);
                        shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(2), sphericalHarmonicsTextureSize);
                        vec4 sampledSH891011 = texture(sphericalHarmonicsTexture, shUV);
                        sh1 = vec3(sampledSH0123.rgb) * (1.0 - fOddOffset) + vec3(sampledSH0123.ba, sampledSH4567.r) * fOddOffset;
                        sh2 = vec3(sampledSH0123.a, sampledSH4567.rg) * (1.0 - fOddOffset) + vec3(sampledSH4567.gba) * fOddOffset;
                        sh3 = vec3(sampledSH4567.ba, sampledSH891011.r) * (1.0 - fOddOffset) + vec3(sampledSH891011.rgb) * fOddOffset;
                    } else {
                        vec2 sampledSH01R = texture(sphericalHarmonicsTextureR, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH23R = texture(sphericalHarmonicsTextureR, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH01G = texture(sphericalHarmonicsTextureG, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH23G = texture(sphericalHarmonicsTextureG, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH01B = texture(sphericalHarmonicsTextureB, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH23B = texture(sphericalHarmonicsTextureB, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;
                        sh1 = vec3(sampledSH01R.rg, sampledSH23R.r);
                        sh2 = vec3(sampledSH01G.rg, sampledSH23G.r);
                        sh3 = vec3(sampledSH01B.rg, sampledSH23B.r);
                    }
                `:t===2&&(o+=`
                    vec4 sampledSH0123;
                    vec4 sampledSH4567;
                    vec4 sampledSH891011;

                    vec4 sampledSH0123R;
                    vec4 sampledSH0123G;
                    vec4 sampledSH0123B;

                    if (sphericalHarmonicsMultiTextureMode == 0) {
                        sampledSH0123 = texture(sphericalHarmonicsTexture, getDataUV(6, 0, sphericalHarmonicsTextureSize));
                        sampledSH4567 = texture(sphericalHarmonicsTexture, getDataUV(6, 1, sphericalHarmonicsTextureSize));
                        sampledSH891011 = texture(sphericalHarmonicsTexture, getDataUV(6, 2, sphericalHarmonicsTextureSize));
                        sh1 = sampledSH0123.rgb;
                        sh2 = vec3(sampledSH0123.a, sampledSH4567.rg);
                        sh3 = vec3(sampledSH4567.ba, sampledSH891011.r);
                    } else {
                        sampledSH0123R = texture(sphericalHarmonicsTextureR, getDataUV(2, 0, sphericalHarmonicsTextureSize));
                        sampledSH0123G = texture(sphericalHarmonicsTextureG, getDataUV(2, 0, sphericalHarmonicsTextureSize));
                        sampledSH0123B = texture(sphericalHarmonicsTextureB, getDataUV(2, 0, sphericalHarmonicsTextureSize));
                        sh1 = vec3(sampledSH0123R.rgb);
                        sh2 = vec3(sampledSH0123G.rgb);
                        sh3 = vec3(sampledSH0123B.rgb);
                    }
                `),o+=`
                    if (sphericalHarmonics8BitMode == 1) {
                        sh1 = sh1 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                        sh2 = sh2 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                        sh3 = sh3 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                    }
                    float x = worldViewDir.x;
                    float y = worldViewDir.y;
                    float z = worldViewDir.z;
                    vColor.rgb += SH_C1 * (-sh1 * y + sh2 * z - sh3 * x);
            `,t>=2&&(o+=`
                    if (sphericalHarmonicsDegree >= 2) {
                        float xx = x * x;
                        float yy = y * y;
                        float zz = z * z;
                        float xy = x * y;
                        float yz = y * z;
                        float xz = x * z;
                `,t===2&&(o+=`
                        if (sphericalHarmonicsMultiTextureMode == 0) {
                            vec4 sampledSH12131415 = texture(sphericalHarmonicsTexture, getDataUV(6, 3, sphericalHarmonicsTextureSize));
                            vec4 sampledSH16171819 = texture(sphericalHarmonicsTexture, getDataUV(6, 4, sphericalHarmonicsTextureSize));
                            vec4 sampledSH20212223 = texture(sphericalHarmonicsTexture, getDataUV(6, 5, sphericalHarmonicsTextureSize));
                            sh4 = sampledSH891011.gba;
                            sh5 = sampledSH12131415.rgb;
                            sh6 = vec3(sampledSH12131415.a, sampledSH16171819.rg);
                            sh7 = vec3(sampledSH16171819.ba, sampledSH20212223.r);
                            sh8 = sampledSH20212223.gba;
                        } else {
                            vec4 sampledSH4567R = texture(sphericalHarmonicsTextureR, getDataUV(2, 1, sphericalHarmonicsTextureSize));
                            vec4 sampledSH4567G = texture(sphericalHarmonicsTextureG, getDataUV(2, 1, sphericalHarmonicsTextureSize));
                            vec4 sampledSH4567B = texture(sphericalHarmonicsTextureB, getDataUV(2, 1, sphericalHarmonicsTextureSize));
                            sh4 = vec3(sampledSH0123R.a, sampledSH4567R.rg);
                            sh5 = vec3(sampledSH4567R.ba, sampledSH0123G.a);
                            sh6 = vec3(sampledSH4567G.rgb);
                            sh7 = vec3(sampledSH4567G.a, sampledSH0123B.a, sampledSH4567B.r);
                            sh8 = vec3(sampledSH4567B.gba);
                        }
                    `),o+=`
                        if (sphericalHarmonics8BitMode == 1) {
                            sh4 = sh4 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                            sh5 = sh5 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                            sh6 = sh6 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                            sh7 = sh7 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                            sh8 = sh8 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                        }

                        vColor.rgb +=
                            (SH_C2[0] * xy) * sh4 +
                            (SH_C2[1] * yz) * sh5 +
                            (SH_C2[2] * (2.0 * zz - xx - yy)) * sh6 +
                            (SH_C2[3] * xz) * sh7 +
                            (SH_C2[4] * (xx - yy)) * sh8;
                    }
                `),o+=`

                vColor.rgb = clamp(vColor.rgb, vec3(0.), vec3(1.));

            }

            `),o}static getVertexShaderFadeIn(){return`
            if (fadeInComplete == 0) {
                float opacityAdjust = 1.0;
                float centerDist = length(splatCenter - sceneCenter);
                float renderTime = max(currentTime - firstRenderTime, 0.0);

                float fadeDistance = 0.75;
                float distanceLoadFadeInFactor = step(visibleRegionFadeStartRadius, centerDist);
                distanceLoadFadeInFactor = (1.0 - distanceLoadFadeInFactor) +
                                        (1.0 - clamp((centerDist - visibleRegionFadeStartRadius) / fadeDistance, 0.0, 1.0)) *
                                        distanceLoadFadeInFactor;
                opacityAdjust *= distanceLoadFadeInFactor;
                vColor.a *= opacityAdjust;
            }
        `}static getUniforms(e=!1,s=!1,t=0,n=1,o=!1){const i={sceneCenter:{type:"v3",value:new v},fadeInComplete:{type:"i",value:0},orthographicMode:{type:"i",value:0},visibleRegionFadeStartRadius:{type:"f",value:0},visibleRegionRadius:{type:"f",value:0},currentTime:{type:"f",value:0},firstRenderTime:{type:"f",value:0},centersColorsTexture:{type:"t",value:null},sphericalHarmonicsTexture:{type:"t",value:null},sphericalHarmonicsTextureR:{type:"t",value:null},sphericalHarmonicsTextureG:{type:"t",value:null},sphericalHarmonicsTextureB:{type:"t",value:null},sphericalHarmonics8BitCompressionRangeMin:{type:"f",value:[]},sphericalHarmonics8BitCompressionRangeMax:{type:"f",value:[]},focal:{type:"v2",value:new N},orthoZoom:{type:"f",value:1},inverseFocalAdjustment:{type:"f",value:1},viewport:{type:"v2",value:new N},basisViewport:{type:"v2",value:new N},debugColor:{type:"v3",value:new Et},centersColorsTextureSize:{type:"v2",value:new N(1024,1024)},sphericalHarmonicsDegree:{type:"i",value:t},sphericalHarmonicsTextureSize:{type:"v2",value:new N(1024,1024)},sphericalHarmonics8BitMode:{type:"i",value:0},sphericalHarmonicsMultiTextureMode:{type:"i",value:0},splatScale:{type:"f",value:n},pointCloudModeEnabled:{type:"i",value:o?1:0},sceneIndexesTexture:{type:"t",value:null},sceneIndexesTextureSize:{type:"v2",value:new N(1024,1024)},sceneCount:{type:"i",value:1}};for(let r=0;r<Y.MaxScenes;r++)i.sphericalHarmonics8BitCompressionRangeMin.value.push(-3/2),i.sphericalHarmonics8BitCompressionRangeMax.value.push(Y.SphericalHarmonics8BitCompressionRange/2);if(s){const r=[];for(let l=0;l<Y.MaxScenes;l++)r.push(1);i.sceneOpacity={type:"f",value:r};const a=[];for(let l=0;l<Y.MaxScenes;l++)a.push(1);i.sceneVisibility={type:"i",value:a}}if(e){const r=[];for(let a=0;a<Y.MaxScenes;a++)r.push(new J);i.transforms={type:"mat4",value:r}}return i}}class vt{static build(e=!1,s=!1,t=!1,n=2048,o=1,i=!1,r=0,a=.3){let c=Ze.buildVertexShaderBase(e,s,r,`
            uniform vec2 covariancesTextureSize;
            uniform highp sampler2D covariancesTexture;
            uniform highp usampler2D covariancesTextureHalfFloat;
            uniform int covariancesAreHalfFloat;

            void fromCovarianceHalfFloatV4(uvec4 val, out vec4 first, out vec4 second) {
                vec2 r = unpackHalf2x16(val.r);
                vec2 g = unpackHalf2x16(val.g);
                vec2 b = unpackHalf2x16(val.b);

                first = vec4(r.x, r.y, g.x, g.y);
                second = vec4(b.x, b.y, 0.0, 0.0);
            }
        `);c+=vt.buildVertexShaderProjection(t,s,n,a);const d=vt.buildFragmentShader(),u=Ze.getUniforms(e,s,r,o,i);return u.covariancesTextureSize={type:"v2",value:new N(1024,1024)},u.covariancesTexture={type:"t",value:null},u.covariancesTextureHalfFloat={type:"t",value:null},u.covariancesAreHalfFloat={type:"i",value:0},new it({uniforms:u,vertexShader:c,fragmentShader:d,transparent:!0,alphaTest:1,blending:$s,depthTest:!0,depthWrite:!1,side:Wt})}static buildVertexShaderProjection(e,s,t,n){let o=`

            vec4 sampledCovarianceA;
            vec4 sampledCovarianceB;
            vec3 cov3D_M11_M12_M13;
            vec3 cov3D_M22_M23_M33;
            if (covariancesAreHalfFloat == 0) {
                sampledCovarianceA = texture(covariancesTexture, getDataUVF(nearestEvenIndex, 1.5, oddOffset,
                                                                            covariancesTextureSize));
                sampledCovarianceB = texture(covariancesTexture, getDataUVF(nearestEvenIndex, 1.5, oddOffset + uint(1),
                                                                            covariancesTextureSize));

                cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rgb) * (1.0 - fOddOffset) +
                                    vec3(sampledCovarianceA.ba, sampledCovarianceB.r) * fOddOffset;
                cov3D_M22_M23_M33 = vec3(sampledCovarianceA.a, sampledCovarianceB.rg) * (1.0 - fOddOffset) +
                                    vec3(sampledCovarianceB.gba) * fOddOffset;
            } else {
                uvec4 sampledCovarianceU = texture(covariancesTextureHalfFloat, getDataUV(1, 0, covariancesTextureSize));
                fromCovarianceHalfFloatV4(sampledCovarianceU, sampledCovarianceA, sampledCovarianceB);
                cov3D_M11_M12_M13 = sampledCovarianceA.rgb;
                cov3D_M22_M23_M33 = vec3(sampledCovarianceA.a, sampledCovarianceB.rg);
            }
        
            // Construct the 3D covariance matrix
            mat3 Vrk = mat3(
                cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,
                cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,
                cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z
            );

            mat3 J;
            if (orthographicMode == 1) {
                // Since the projection is linear, we don't need an approximation
                J = transpose(mat3(orthoZoom, 0.0, 0.0,
                                0.0, orthoZoom, 0.0,
                                0.0, 0.0, 0.0));
            } else {
                // Construct the Jacobian of the affine approximation of the projection matrix. It will be used to transform the
                // 3D covariance matrix instead of using the actual projection matrix because that transformation would
                // require a non-linear component (perspective division) which would yield a non-gaussian result.
                float s = 1.0 / (viewCenter.z * viewCenter.z);
                J = mat3(
                    focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,
                    0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,
                    0., 0., 0.
                );
            }

            // Concatenate the projection approximation with the model-view transformation
            mat3 W = transpose(mat3(transformModelViewMatrix));
            mat3 T = W * J;

            // Transform the 3D covariance matrix (Vrk) to compute the 2D covariance matrix
            mat3 cov2Dm = transpose(T) * Vrk * T;
            `;return e?o+=`
                float detOrig = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];
                cov2Dm[0][0] += ${n};
                cov2Dm[1][1] += ${n};
                float detBlur = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];
                vColor.a *= sqrt(max(detOrig / detBlur, 0.0));
                if (vColor.a < minAlpha) return;
            `:o+=`
                cov2Dm[0][0] += ${n};
                cov2Dm[1][1] += ${n};
            `,o+=`

            // We are interested in the upper-left 2x2 portion of the projected 3D covariance matrix because
            // we only care about the X and Y values. We want the X-diagonal, cov2Dm[0][0],
            // the Y-diagonal, cov2Dm[1][1], and the correlation between the two cov2Dm[0][1]. We don't
            // need cov2Dm[1][0] because it is a symetric matrix.
            vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);

            // We now need to solve for the eigen-values and eigen vectors of the 2D covariance matrix
            // so that we can determine the 2D basis for the splat. This is done using the method described
            // here: https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
            // After calculating the eigen-values and eigen-vectors, we calculate the basis for rendering the splat
            // by normalizing the eigen-vectors and then multiplying them by (sqrt(8) * sqrt(eigen-value)), which is
            // equal to scaling them by sqrt(8) standard deviations.
            //
            // This is a different approach than in the original work at INRIA. In that work they compute the
            // max extents of the projected splat in screen space to form a screen-space aligned bounding rectangle
            // which forms the geometry that is actually rasterized. The dimensions of that bounding box are 3.0
            // times the square root of the maximum eigen-value, or 3 standard deviations. They then use the inverse
            // 2D covariance matrix (called 'conic') in the CUDA rendering thread to determine fragment opacity by
            // calculating the full gaussian: exp(-0.5 * (X - mean) * conic * (X - mean)) * splat opacity
            float a = cov2Dv.x;
            float d = cov2Dv.z;
            float b = cov2Dv.y;
            float D = a * d - b * b;
            float trace = a + d;
            float traceOver2 = 0.5 * trace;
            float term2 = sqrt(max(0.1f, traceOver2 * traceOver2 - D));
            float eigenValue1 = traceOver2 + term2;
            float eigenValue2 = traceOver2 - term2;

            if (pointCloudModeEnabled == 1) {
                eigenValue1 = eigenValue2 = 0.2;
            }

            if (eigenValue2 <= 0.0) return;

            vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));
            // since the eigen vectors are orthogonal, we derive the second one from the first
            vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);

            // We use sqrt(8) standard deviations instead of 3 to eliminate more of the splat with a very low opacity.
            vec2 basisVector1 = eigenVector1 * splatScale * min(sqrt8 * sqrt(eigenValue1), ${parseInt(t)}.0);
            vec2 basisVector2 = eigenVector2 * splatScale * min(sqrt8 * sqrt(eigenValue2), ${parseInt(t)}.0);
            `,s&&(o+=`
                vColor.a *= splatOpacityFromScene;
            `),o+=`
            vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) *
                             basisViewport * 2.0 * inverseFocalAdjustment;

            vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);
            gl_Position = quadPos;

            // Scale the position data we send to the fragment shader
            vPosition *= sqrt8;
        `,o+=Ze.getVertexShaderFadeIn(),o+="}",o}static buildFragmentShader(){let e=`
            precision highp float;
            #include <common>
 
            uniform vec3 debugColor;

            varying vec4 vColor;
            varying vec2 vUv;
            varying vec2 vPosition;
        `;return e+=`
            void main () {
                // Compute the positional squared distance from the center of the splat to the current fragment.
                float A = dot(vPosition, vPosition);
                // Since the positional data in vPosition has been scaled by sqrt(8), the squared result will be
                // scaled by a factor of 8. If the squared result is larger than 8, it means it is outside the ellipse
                // defined by the rectangle formed by vPosition. It also means it's farther
                // away than sqrt(8) standard deviations from the mean.
                if (A > 8.0) discard;
                vec3 color = vColor.rgb;

                // Since the rendered splat is scaled by sqrt(8), the inverse covariance matrix that is part of
                // the gaussian formula becomes the identity matrix. We're then left with (X - mean) * (X - mean),
                // and since 'mean' is zero, we have X * X, which is the same as A:
                float opacity = exp(-0.5 * A) * vColor.a;

                gl_FragColor = vec4(color.rgb, opacity);
            }
        `,e}}class Ft{static build(e=!1,s=!1,t=1,n=!1,o=0){let r=Ze.buildVertexShaderBase(e,s,o,`
            uniform vec2 scaleRotationsTextureSize;
            uniform highp sampler2D scaleRotationsTexture;
            varying mat3 vT;
            varying vec2 vQuadCenter;
            varying vec2 vFragCoord;
        `);r+=Ft.buildVertexShaderProjection();const a=Ft.buildFragmentShader(),l=Ze.getUniforms(e,s,o,t,n);return l.scaleRotationsTexture={type:"t",value:null},l.scaleRotationsTextureSize={type:"v2",value:new N(1024,1024)},new it({uniforms:l,vertexShader:r,fragmentShader:a,transparent:!0,alphaTest:1,blending:$s,depthTest:!0,depthWrite:!1,side:Wt})}static buildVertexShaderProjection(){let e=`

            vec4 scaleRotationA = texture(scaleRotationsTexture, getDataUVF(nearestEvenIndex, 1.5,
                                                                            oddOffset, scaleRotationsTextureSize));
            vec4 scaleRotationB = texture(scaleRotationsTexture, getDataUVF(nearestEvenIndex, 1.5,
                                                                            oddOffset + uint(1), scaleRotationsTextureSize));

            vec3 scaleRotation123 = vec3(scaleRotationA.rgb) * (1.0 - fOddOffset) +
                                    vec3(scaleRotationA.ba, scaleRotationB.r) * fOddOffset;
            vec3 scaleRotation456 = vec3(scaleRotationA.a, scaleRotationB.rg) * (1.0 - fOddOffset) +
                                    vec3(scaleRotationB.gba) * fOddOffset;

            float missingW = sqrt(1.0 - scaleRotation456.x * scaleRotation456.x - scaleRotation456.y *
                                    scaleRotation456.y - scaleRotation456.z * scaleRotation456.z);
            mat3 R = quaternionToRotationMatrix(scaleRotation456.r, scaleRotation456.g, scaleRotation456.b, missingW);
            mat3 S = mat3(scaleRotation123.r, 0.0, 0.0,
                            0.0, scaleRotation123.g, 0.0,
                            0.0, 0.0, scaleRotation123.b);
            
            mat3 L = R * S;

            mat3x4 splat2World = mat3x4(vec4(L[0], 0.0),
                                        vec4(L[1], 0.0),
                                        vec4(splatCenter.x, splatCenter.y, splatCenter.z, 1.0));

            mat4 world2ndc = transpose(projectionMatrix * transformModelViewMatrix);

            mat3x4 ndc2pix = mat3x4(vec4(viewport.x / 2.0, 0.0, 0.0, (viewport.x - 1.0) / 2.0),
                                    vec4(0.0, viewport.y / 2.0, 0.0, (viewport.y - 1.0) / 2.0),
                                    vec4(0.0, 0.0, 0.0, 1.0));

            mat3 T = transpose(splat2World) * world2ndc * ndc2pix;
            vec3 normal = vec3(viewMatrix * vec4(L[0][2], L[1][2], L[2][2], 0.0));
        `;return e+=`

                mat4 splat2World4 = mat4(vec4(L[0], 0.0),
                                        vec4(L[1], 0.0),
                                        vec4(L[2], 0.0),
                                        vec4(splatCenter.x, splatCenter.y, splatCenter.z, 1.0));

                mat4 Tt = transpose(transpose(splat2World4) * world2ndc);

                vec4 tempPoint1 = Tt * vec4(1.0, 0.0, 0.0, 1.0);
                tempPoint1 /= tempPoint1.w;

                vec4 tempPoint2 = Tt * vec4(0.0, 1.0, 0.0, 1.0);
                tempPoint2 /= tempPoint2.w;

                vec4 center = Tt * vec4(0.0, 0.0, 0.0, 1.0);
                center /= center.w;

                vec2 basisVector1 = tempPoint1.xy - center.xy;
                vec2 basisVector2 = tempPoint2.xy - center.xy;

                vec2 basisVector1Screen = basisVector1 * 0.5 * viewport;
                vec2 basisVector2Screen = basisVector2 * 0.5 * viewport;

                const float minPix = 1.;
                if (length(basisVector1Screen) < minPix || length(basisVector2Screen) < minPix) {
                    
            vec3 T0 = vec3(T[0][0], T[0][1], T[0][2]);
            vec3 T1 = vec3(T[1][0], T[1][1], T[1][2]);
            vec3 T3 = vec3(T[2][0], T[2][1], T[2][2]);

            vec3 tempPoint = vec3(1.0, 1.0, -1.0);
            float distance = (T3.x * T3.x * tempPoint.x) + (T3.y * T3.y * tempPoint.y) + (T3.z * T3.z * tempPoint.z);
            vec3 f = (1.0 / distance) * tempPoint;
            if (abs(distance) < 0.00001) return;

            float pointImageX = (T0.x * T3.x * f.x) + (T0.y * T3.y * f.y) + (T0.z * T3.z * f.z);
            float pointImageY = (T1.x * T3.x * f.x) + (T1.y * T3.y * f.y) + (T1.z * T3.z * f.z);
            vec2 pointImage = vec2(pointImageX, pointImageY);

            float tempX = (T0.x * T0.x * f.x) + (T0.y * T0.y * f.y) + (T0.z * T0.z * f.z);
            float tempY = (T1.x * T1.x * f.x) + (T1.y * T1.y * f.y) + (T1.z * T1.z * f.z);
            vec2 temp = vec2(tempX, tempY);

            vec2 halfExtend = pointImage * pointImage - temp;
            vec2 extent = sqrt(max(vec2(0.0001), halfExtend));
            float radius = max(extent.x, extent.y);

            vec2 ndcOffset = ((position.xy * radius * 3.0) * basisViewport * 2.0);

            vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);
            gl_Position = quadPos;

            vT = T;
            vQuadCenter = pointImage;
            vFragCoord = (quadPos.xy * 0.5 + 0.5) * viewport;
        
                } else {
                    vec2 ndcOffset = vec2(position.x * basisVector1 + position.y * basisVector2) * 3.0 * inverseFocalAdjustment;
                    vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);
                    gl_Position = quadPos;

                    vT = T;
                    vQuadCenter = center.xy;
                    vFragCoord = (quadPos.xy * 0.5 + 0.5) * viewport;
                }
            `,e+=Ze.getVertexShaderFadeIn(),e+="}",e}static buildFragmentShader(){return`
            precision highp float;
            #include <common>

            uniform vec3 debugColor;

            varying vec4 vColor;
            varying vec2 vUv;
            varying vec2 vPosition;
            varying mat3 vT;
            varying vec2 vQuadCenter;
            varying vec2 vFragCoord;

            void main () {

                const float FilterInvSquare = 2.0;
                const float near_n = 0.2;
                const float T = 1.0;

                vec2 xy = vQuadCenter;
                vec3 Tu = vT[0];
                vec3 Tv = vT[1];
                vec3 Tw = vT[2];
                vec3 k = vFragCoord.x * Tw - Tu;
                vec3 l = vFragCoord.y * Tw - Tv;
                vec3 p = cross(k, l);
                if (p.z == 0.0) discard;
                vec2 s = vec2(p.x / p.z, p.y / p.z);
                float rho3d = (s.x * s.x + s.y * s.y); 
                vec2 d = vec2(xy.x - vFragCoord.x, xy.y - vFragCoord.y);
                float rho2d = FilterInvSquare * (d.x * d.x + d.y * d.y); 

                // compute intersection and depth
                float rho = min(rho3d, rho2d);
                float depth = (rho3d <= rho2d) ? (s.x * Tw.x + s.y * Tw.y) + Tw.z : Tw.z; 
                if (depth < near_n) discard;
                //  vec4 nor_o = collected_normal_opacity[j];
                //  float normal[3] = {nor_o.x, nor_o.y, nor_o.z};
                float opa = vColor.a;

                float power = -0.5f * rho;
                if (power > 0.0f) discard;

                // Eq. (2) from 3D Gaussian splatting paper.
                // Obtain alpha by multiplying with Gaussian opacity
                // and its exponential falloff from mean.
                // Avoid numerical instabilities (see paper appendix). 
                float alpha = min(0.99f, opa * exp(power));
                if (alpha < 1.0f / 255.0f) discard;
                float test_T = T * (1.0 - alpha);
                if (test_T < 0.0001)discard;

                float w = alpha * T;
                gl_FragColor = vec4(vColor.rgb, w);
            }
        `}}class qo{static build(e){const s=new Xs;s.setIndex([0,1,2,0,2,3]);const t=new Float32Array(12),n=new Mn(t,3);s.setAttribute("position",n),n.setXYZ(0,-1,-1,0),n.setXYZ(1,-1,1,0),n.setXYZ(2,1,1,0),n.setXYZ(3,1,-1,0),n.needsUpdate=!0;const o=new Pn().copy(s),i=new Uint32Array(e),r=new On(i,1,!1);return r.setUsage(Ln),o.setAttribute("splatIndex",r),o.instanceCount=0,o}}class Wo extends Xe{constructor(e,s=new v,t=new ge,n=new v(1,1,1),o=1,i=1,r=!0){super(),this.splatBuffer=e,this.position.copy(s),this.quaternion.copy(t),this.scale.copy(n),this.transform=new J,this.minimumAlpha=o,this.opacity=i,this.visible=r}copyTransformData(e){this.position.copy(e.position),this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.transform.copy(e.transform)}updateTransform(e){e?(this.matrixWorldAutoUpdate&&this.updateWorldMatrix(!0,!1),this.transform.copy(this.matrixWorld)):(this.matrixAutoUpdate&&this.updateMatrix(),this.transform.copy(this.matrix))}}class cs{static idGen=0;constructor(e,s,t,n){this.min=new v().copy(e),this.max=new v().copy(s),this.boundingBox=new nt(this.min,this.max),this.center=new v().copy(this.max).sub(this.min).multiplyScalar(.5).add(this.min),this.depth=t,this.children=[],this.data=null,this.id=n||cs.idGen++}}class dt{constructor(e,s){this.maxDepth=e,this.maxCentersPerNode=s,this.sceneDimensions=new v,this.sceneMin=new v,this.sceneMax=new v,this.rootNode=null,this.nodesWithIndexes=[],this.splatMesh=null}static convertWorkerSubTreeNode(e){const s=new v().fromArray(e.min),t=new v().fromArray(e.max),n=new cs(s,t,e.depth,e.id);if(e.data.indexes){n.data={indexes:[]};for(let o of e.data.indexes)n.data.indexes.push(o)}if(e.children)for(let o of e.children)n.children.push(dt.convertWorkerSubTreeNode(o));return n}static convertWorkerSubTree(e,s){const t=new dt(e.maxDepth,e.maxCentersPerNode);t.sceneMin=new v().fromArray(e.sceneMin),t.sceneMax=new v().fromArray(e.sceneMax),t.splatMesh=s,t.rootNode=dt.convertWorkerSubTreeNode(e.rootNode);const n=(o,i)=>{o.children.length===0&&i(o);for(let r of o.children)n(r,i)};return t.nodesWithIndexes=[],n(t.rootNode,o=>{o.data&&o.data.indexes&&o.data.indexes.length>0&&t.nodesWithIndexes.push(o)}),t}}function Ko(m){let e=0;class s{constructor(a,l){this.min=[a[0],a[1],a[2]],this.max=[l[0],l[1],l[2]]}containsPoint(a){return a[0]>=this.min[0]&&a[0]<=this.max[0]&&a[1]>=this.min[1]&&a[1]<=this.max[1]&&a[2]>=this.min[2]&&a[2]<=this.max[2]}}class t{constructor(a,l){this.maxDepth=a,this.maxCentersPerNode=l,this.sceneDimensions=[],this.sceneMin=[],this.sceneMax=[],this.rootNode=null,this.addedIndexes={},this.nodesWithIndexes=[],this.splatMesh=null,this.disposed=!1}}class n{constructor(a,l,c,d){this.min=[a[0],a[1],a[2]],this.max=[l[0],l[1],l[2]],this.center=[(l[0]-a[0])*.5+a[0],(l[1]-a[1])*.5+a[1],(l[2]-a[2])*.5+a[2]],this.depth=c,this.children=[],this.data=null,this.id=d||e++}}processSplatTreeNode=function(r,a,l,c){const d=a.data.indexes.length;if(d<r.maxCentersPerNode||a.depth>r.maxDepth){const g=[];for(let x=0;x<a.data.indexes.length;x++)r.addedIndexes[a.data.indexes[x]]||(g.push(a.data.indexes[x]),r.addedIndexes[a.data.indexes[x]]=!0);a.data.indexes=g,a.data.indexes.sort((x,B)=>x>B?1:-1),r.nodesWithIndexes.push(a);return}const u=[a.max[0]-a.min[0],a.max[1]-a.min[1],a.max[2]-a.min[2]],h=[u[0]*.5,u[1]*.5,u[2]*.5],f=[a.min[0]+h[0],a.min[1]+h[1],a.min[2]+h[2]],p=[new s([f[0]-h[0],f[1],f[2]-h[2]],[f[0],f[1]+h[1],f[2]]),new s([f[0],f[1],f[2]-h[2]],[f[0]+h[0],f[1]+h[1],f[2]]),new s([f[0],f[1],f[2]],[f[0]+h[0],f[1]+h[1],f[2]+h[2]]),new s([f[0]-h[0],f[1],f[2]],[f[0],f[1]+h[1],f[2]+h[2]]),new s([f[0]-h[0],f[1]-h[1],f[2]-h[2]],[f[0],f[1],f[2]]),new s([f[0],f[1]-h[1],f[2]-h[2]],[f[0]+h[0],f[1],f[2]]),new s([f[0],f[1]-h[1],f[2]],[f[0]+h[0],f[1],f[2]+h[2]]),new s([f[0]-h[0],f[1]-h[1],f[2]],[f[0],f[1],f[2]+h[2]])],A=[];for(let g=0;g<p.length;g++)A[g]=[];const C=[0,0,0];for(let g=0;g<d;g++){const x=a.data.indexes[g],B=l[x];C[0]=c[B],C[1]=c[B+1],C[2]=c[B+2];for(let y=0;y<p.length;y++)p[y].containsPoint(C)&&A[y].push(x)}for(let g=0;g<p.length;g++){const x=new n(p[g].min,p[g].max,a.depth+1);x.data={indexes:A[g]},a.children.push(x)}a.data={};for(let g of a.children)processSplatTreeNode(r,g,l,c)};const o=(r,a,l)=>{const c=[0,0,0],d=[0,0,0],u=[],h=Math.floor(r.length/4);for(let p=0;p<h;p++){const A=p*4,C=r[A],g=r[A+1],x=r[A+2],B=Math.round(r[A+3]);(p===0||C<c[0])&&(c[0]=C),(p===0||C>d[0])&&(d[0]=C),(p===0||g<c[1])&&(c[1]=g),(p===0||g>d[1])&&(d[1]=g),(p===0||x<c[2])&&(c[2]=x),(p===0||x>d[2])&&(d[2]=x),u.push(B)}const f=new t(a,l);return f.sceneMin=c,f.sceneMax=d,f.rootNode=new n(f.sceneMin,f.sceneMax,0),f.rootNode.data={indexes:u},f};function i(r,a,l){const c=[];for(let u of r){const h=Math.floor(u.length/4);for(let f=0;f<h;f++){const p=f*4,A=Math.round(u[p+3]);c[A]=p}}const d=[];for(let u of r){const h=o(u,a,l);d.push(h),processSplatTreeNode(h,h.rootNode,c,u)}m.postMessage({subTrees:d})}m.onmessage=r=>{r.data.process&&i(r.data.process.centers,r.data.process.maxDepth,r.data.process.maxCentersPerNode)}}function jo(m,e,s,t,n){m.postMessage({process:{centers:e,maxDepth:t,maxCentersPerNode:n}},s)}function Yo(){return new Worker(URL.createObjectURL(new Blob(["(",Ko.toString(),")(self)"],{type:"application/javascript"})))}class Xo{constructor(e,s){this.maxDepth=e,this.maxCentersPerNode=s,this.subTrees=[],this.splatMesh=null}dispose(){this.diposeSplatTreeWorker(),this.disposed=!0}diposeSplatTreeWorker(){this.splatTreeWorker&&this.splatTreeWorker.terminate(),this.splatTreeWorker=null}processSplatMesh=function(e,s=()=>!0,t,n){this.splatTreeWorker||(this.splatTreeWorker=Yo()),this.splatMesh=e,this.subTrees=[];const o=new v,i=(r,a)=>{const l=new Float32Array(a*4);let c=0;for(let d=0;d<a;d++){const u=d+r;if(s(u)){e.getSplatCenter(u,o);const h=c*4;l[h]=o.x,l[h+1]=o.y,l[h+2]=o.z,l[h+3]=u,c++}}return l};return new Promise(r=>{const a=()=>this.disposed?(this.diposeSplatTreeWorker(),r(),!0):!1;t&&t(!1),ve(()=>{if(a())return;const l=[];if(e.dynamicMode){let c=0;for(let d=0;d<e.scenes.length;d++){const h=e.getScene(d).splatBuffer.getSplatCount(),f=i(c,h);l.push(f),c+=h}}else{const c=i(0,e.getSplatCount());l.push(c)}this.splatTreeWorker.onmessage=c=>{a()||c.data.subTrees&&(n&&n(!1),ve(()=>{if(!a()){for(let d of c.data.subTrees){const u=dt.convertWorkerSubTree(d,e);this.subTrees.push(u)}this.diposeSplatTreeWorker(),n&&n(!0),ve(()=>{r()})}}))},ve(()=>{if(a())return;t&&t(!0);const c=l.map(d=>d.buffer);jo(this.splatTreeWorker,l,c,this.maxDepth,this.maxCentersPerNode)})})})};countLeaves(){let e=0;return this.visitLeaves(()=>{e++}),e}visitLeaves(e){const s=(t,n)=>{t.children.length===0&&n(t);for(let o of t.children)s(o,n)};for(let t of this.subTrees)s(t.rootNode,e)}}function Jo(m){const e={};function s(t){if(e[t]!==void 0)return e[t];let n;switch(t){case"WEBGL_depth_texture":n=m.getExtension("WEBGL_depth_texture")||m.getExtension("MOZ_WEBGL_depth_texture")||m.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":n=m.getExtension("EXT_texture_filter_anisotropic")||m.getExtension("MOZ_EXT_texture_filter_anisotropic")||m.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":n=m.getExtension("WEBGL_compressed_texture_s3tc")||m.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||m.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":n=m.getExtension("WEBGL_compressed_texture_pvrtc")||m.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:n=m.getExtension(t)}return e[t]=n,n}return{has:function(t){return s(t)!==null},init:function(t){t.isWebGL2?(s("EXT_color_buffer_float"),s("WEBGL_clip_cull_distance")):(s("WEBGL_depth_texture"),s("OES_texture_float"),s("OES_texture_half_float"),s("OES_texture_half_float_linear"),s("OES_standard_derivatives"),s("OES_element_index_uint"),s("OES_vertex_array_object"),s("ANGLE_instanced_arrays")),s("OES_texture_float_linear"),s("EXT_color_buffer_half_float"),s("WEBGL_multisampled_render_to_texture")},get:function(t){const n=s(t);return n===null&&console.warn("THREE.WebGLRenderer: "+t+" extension not supported."),n}}}function Zo(m,e,s){let t;function n(){if(t!==void 0)return t;if(e.has("EXT_texture_filter_anisotropic")===!0){const S=e.get("EXT_texture_filter_anisotropic");t=m.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else t=0;return t}function o(S){if(S==="highp"){if(m.getShaderPrecisionFormat(m.VERTEX_SHADER,m.HIGH_FLOAT).precision>0&&m.getShaderPrecisionFormat(m.FRAGMENT_SHADER,m.HIGH_FLOAT).precision>0)return"highp";S="mediump"}return S==="mediump"&&m.getShaderPrecisionFormat(m.VERTEX_SHADER,m.MEDIUM_FLOAT).precision>0&&m.getShaderPrecisionFormat(m.FRAGMENT_SHADER,m.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const i=typeof WebGL2RenderingContext<"u"&&m.constructor.name==="WebGL2RenderingContext";let r=s.precision!==void 0?s.precision:"highp";const a=o(r);a!==r&&(console.warn("THREE.WebGLRenderer:",r,"not supported, using",a,"instead."),r=a);const l=i||e.has("WEBGL_draw_buffers"),c=s.logarithmicDepthBuffer===!0,d=m.getParameter(m.MAX_TEXTURE_IMAGE_UNITS),u=m.getParameter(m.MAX_VERTEX_TEXTURE_IMAGE_UNITS),h=m.getParameter(m.MAX_TEXTURE_SIZE),f=m.getParameter(m.MAX_CUBE_MAP_TEXTURE_SIZE),p=m.getParameter(m.MAX_VERTEX_ATTRIBS),A=m.getParameter(m.MAX_VERTEX_UNIFORM_VECTORS),C=m.getParameter(m.MAX_VARYING_VECTORS),g=m.getParameter(m.MAX_FRAGMENT_UNIFORM_VECTORS),x=u>0,B=i||e.has("OES_texture_float"),y=x&&B,E=i?m.getParameter(m.MAX_SAMPLES):0;return{isWebGL2:i,drawBuffers:l,getMaxAnisotropy:n,getMaxPrecision:o,precision:r,logarithmicDepthBuffer:c,maxTextures:d,maxVertexTextures:u,maxTextureSize:h,maxCubemapSize:f,maxAttributes:p,maxVertexUniforms:A,maxVaryings:C,maxFragmentUniforms:g,vertexTextures:x,floatFragmentTextures:B,floatVertexTextures:y,maxSamples:E}}const ht={Default:0,Instant:2},$e={None:0,Info:3},qs=new Xs,$o=new pt,Tt=6,er=4,tr=4,sr=4,nr=6,or=8,_t=4,Qt=4,Ws=1,rr=.012,ir=.003,Ks=1,js=16777216;class ye extends De{constructor(e=Le.ThreeD,s=!1,t=!1,n=!1,o=1,i=!0,r=!1,a=!1,l=1024,c=$e.None,d=0,u=1,h=.3){super(qs,$o),this.renderer=void 0,this.splatRenderMode=e,this.dynamicMode=s,this.enableOptionalEffects=t,this.halfPrecisionCovariancesOnGPU=n,this.devicePixelRatio=o,this.enableDistancesComputationOnGPU=i,this.integerBasedDistancesComputation=r,this.antialiased=a,this.kernel2DSize=h,this.maxScreenSpaceSplatSize=l,this.logLevel=c,this.sphericalHarmonicsDegree=d,this.minSphericalHarmonicsDegree=0,this.sceneFadeInRateMultiplier=u,this.scenes=[],this.splatTree=null,this.baseSplatTree=null,this.splatDataTextures={},this.distancesTransformFeedback={id:null,vertexShader:null,fragmentShader:null,program:null,centersBuffer:null,sceneIndexesBuffer:null,outDistancesBuffer:null,centersLoc:-1,modelViewProjLoc:-1,sceneIndexesLoc:-1,transformsLocs:[]},this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSceneIndexMap=[],this.lastBuildSplatCount=0,this.lastBuildScenes=[],this.lastBuildMaxSplatCount=0,this.lastBuildSceneCount=0,this.firstRenderTime=-1,this.finalBuild=!1,this.webGLUtils=null,this.boundingBox=new nt,this.calculatedSceneCenter=new v,this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.visibleRegionChanging=!1,this.splatScale=1,this.pointCloudModeEnabled=!1,this.disposed=!1,this.lastRenderer=null,this.visible=!1}static buildScenes(e,s,t){const n=[];n.length=s.length;for(let o=0;o<s.length;o++){const i=s[o],r=t[o]||{};let a=r.position||[0,0,0],l=r.rotation||[0,0,0,1],c=r.scale||[1,1,1];const d=new v().fromArray(a),u=new ge().fromArray(l),h=new v().fromArray(c),f=ye.createScene(i,d,u,h,r.splatAlphaRemovalThreshold||1,r.opacity,r.visible);e.add(f),n[o]=f}return n}static createScene(e,s,t,n,o,i=1,r=!0){return new Wo(e,s,t,n,o,i,r)}static buildSplatIndexMaps(e){const s=[],t=[];let n=0;for(let o=0;o<e.length;o++){const r=e[o].getMaxSplatCount();for(let a=0;a<r;a++)s[n]=a,t[n]=o,n++}return{localSplatIndexMap:s,sceneIndexMap:t}}buildSplatTree=function(e=[],s,t){return new Promise(n=>{this.disposeSplatTree(),this.baseSplatTree=new Xo(8,1e3);const o=performance.now(),i=new qt;this.baseSplatTree.processSplatMesh(this,r=>{this.getSplatColor(r,i);const a=this.getSceneIndexForSplat(r),l=e[a]||1;return i.w>=l},s,t).then(()=>{const r=performance.now()-o;if(this.logLevel>=$e.Info&&console.log("SplatTree build: "+r+" ms"),this.disposed)n();else{this.splatTree=this.baseSplatTree,this.baseSplatTree=null;let a=0,l=0,c=0;this.splatTree.visitLeaves(d=>{const u=d.data.indexes.length;u>0&&(l+=u,c++,a++)}),this.logLevel>=$e.Info&&(console.log(`SplatTree leaves: ${this.splatTree.countLeaves()}`),console.log(`SplatTree leaves with splats:${a}`),l=l/c,console.log(`Avg splat count per node: ${l}`),console.log(`Total splat count: ${this.getSplatCount()}`)),n()}})})};build(e,s,t=!0,n=!1,o,i,r=!0){this.sceneOptions=s,this.finalBuild=n;const a=ye.getTotalMaxSplatCountForSplatBuffers(e),l=ye.buildScenes(this,e,s);if(t)for(let p=0;p<this.scenes.length&&p<l.length;p++){const A=l[p],C=this.getScene(p);A.copyTransformData(C)}this.scenes=l;let c=3;for(let p of e){const A=p.getMinSphericalHarmonicsDegree();A<c&&(c=A)}this.minSphericalHarmonicsDegree=Math.min(c,this.sphericalHarmonicsDegree);let d=!1;if(e.length!==this.lastBuildScenes.length)d=!0;else for(let p=0;p<e.length;p++)if(e[p]!==this.lastBuildScenes[p].splatBuffer){d=!0;break}let u=!0;if((this.scenes.length!==1||this.lastBuildSceneCount!==this.scenes.length||this.lastBuildMaxSplatCount!==a||d)&&(u=!1),!u){this.boundingBox=new nt,r||(this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.firstRenderTime=-1),this.lastBuildScenes=[],this.lastBuildSplatCount=0,this.lastBuildMaxSplatCount=0,this.disposeMeshData(),this.geometry=qo.build(a),this.splatRenderMode===Le.ThreeD?this.material=vt.build(this.dynamicMode,this.enableOptionalEffects,this.antialiased,this.maxScreenSpaceSplatSize,this.splatScale,this.pointCloudModeEnabled,this.minSphericalHarmonicsDegree,this.kernel2DSize):this.material=Ft.build(this.dynamicMode,this.enableOptionalEffects,this.splatScale,this.pointCloudModeEnabled,this.minSphericalHarmonicsDegree);const p=ye.buildSplatIndexMaps(e);this.globalSplatIndexToLocalSplatIndexMap=p.localSplatIndexMap,this.globalSplatIndexToSceneIndexMap=p.sceneIndexMap}const h=this.getSplatCount(!0);this.enableDistancesComputationOnGPU&&this.setupDistancesComputationTransformFeedback();const f=this.refreshGPUDataFromSplatBuffers(u);for(let p=0;p<this.scenes.length;p++)this.lastBuildScenes[p]=this.scenes[p];return this.lastBuildSplatCount=h,this.lastBuildMaxSplatCount=this.getMaxSplatCount(),this.lastBuildSceneCount=this.scenes.length,n&&this.scenes.length>0&&this.buildSplatTree(s.map(p=>p.splatAlphaRemovalThreshold||1),o,i).then(()=>{this.onSplatTreeReadyCallback&&this.onSplatTreeReadyCallback(this.splatTree),this.onSplatTreeReadyCallback=null}),this.visible=this.scenes.length>0,f}freeIntermediateSplatData(){const e=s=>{delete s.source.data,delete s.image,s.onUpdate=null};delete this.splatDataTextures.baseData.covariances,delete this.splatDataTextures.baseData.centers,delete this.splatDataTextures.baseData.colors,delete this.splatDataTextures.baseData.sphericalHarmonics,delete this.splatDataTextures.centerColors.data,delete this.splatDataTextures.covariances.data,this.splatDataTextures.sphericalHarmonics&&delete this.splatDataTextures.sphericalHarmonics.data,this.splatDataTextures.sceneIndexes&&delete this.splatDataTextures.sceneIndexes.data,this.splatDataTextures.centerColors.texture.needsUpdate=!0,this.splatDataTextures.centerColors.texture.onUpdate=()=>{e(this.splatDataTextures.centerColors.texture)},this.splatDataTextures.covariances.texture.needsUpdate=!0,this.splatDataTextures.covariances.texture.onUpdate=()=>{e(this.splatDataTextures.covariances.texture)},this.splatDataTextures.sphericalHarmonics&&(this.splatDataTextures.sphericalHarmonics.texture?(this.splatDataTextures.sphericalHarmonics.texture.needsUpdate=!0,this.splatDataTextures.sphericalHarmonics.texture.onUpdate=()=>{e(this.splatDataTextures.sphericalHarmonics.texture)}):this.splatDataTextures.sphericalHarmonics.textures.forEach(s=>{s.needsUpdate=!0,s.onUpdate=()=>{e(s)}})),this.splatDataTextures.sceneIndexes&&(this.splatDataTextures.sceneIndexes.texture.needsUpdate=!0,this.splatDataTextures.sceneIndexes.texture.onUpdate=()=>{e(this.splatDataTextures.sceneIndexes.texture)})}dispose(){this.disposeMeshData(),this.disposeTextures(),this.disposeSplatTree(),this.enableDistancesComputationOnGPU&&(this.computeDistancesOnGPUSyncTimeout&&(clearTimeout(this.computeDistancesOnGPUSyncTimeout),this.computeDistancesOnGPUSyncTimeout=null),this.disposeDistancesComputationGPUResources()),this.scenes=[],this.distancesTransformFeedback={id:null,vertexShader:null,fragmentShader:null,program:null,centersBuffer:null,sceneIndexesBuffer:null,outDistancesBuffer:null,centersLoc:-1,modelViewProjLoc:-1,sceneIndexesLoc:-1,transformsLocs:[]},this.renderer=null,this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSceneIndexMap=[],this.lastBuildSplatCount=0,this.lastBuildScenes=[],this.lastBuildMaxSplatCount=0,this.lastBuildSceneCount=0,this.firstRenderTime=-1,this.finalBuild=!1,this.webGLUtils=null,this.boundingBox=new nt,this.calculatedSceneCenter=new v,this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.visibleRegionChanging=!1,this.splatScale=1,this.pointCloudModeEnabled=!1,this.disposed=!0,this.lastRenderer=null,this.visible=!1}disposeMeshData(){this.geometry&&this.geometry!==qs&&(this.geometry.dispose(),this.geometry=null),this.material&&(this.material.dispose(),this.material=null)}disposeTextures(){for(let e in this.splatDataTextures)if(this.splatDataTextures.hasOwnProperty(e)){const s=this.splatDataTextures[e];s.texture&&(s.texture.dispose(),s.texture=null)}this.splatDataTextures=null}disposeSplatTree(){this.splatTree&&(this.splatTree.dispose(),this.splatTree=null),this.baseSplatTree&&(this.baseSplatTree.dispose(),this.baseSplatTree=null)}getSplatTree(){return this.splatTree}onSplatTreeReady(e){this.onSplatTreeReadyCallback=e}getDataForDistancesComputation(e,s){const t=this.integerBasedDistancesComputation?this.getIntegerCenters(e,s,!0):this.getFloatCenters(e,s,!0),n=this.getSceneIndexes(e,s);return{centers:t,sceneIndexes:n}}refreshGPUDataFromSplatBuffers(e){const s=this.getSplatCount(!0);this.refreshDataTexturesFromSplatBuffers(e);const t=e?this.lastBuildSplatCount:0,{centers:n,sceneIndexes:o}=this.getDataForDistancesComputation(t,s-1);return this.enableDistancesComputationOnGPU&&this.refreshGPUBuffersForDistancesComputation(n,o,e),{from:t,to:s-1,count:s-t,centers:n,sceneIndexes:o}}refreshGPUBuffersForDistancesComputation(e,s,t=!1){const n=t?this.lastBuildSplatCount:0;this.updateGPUCentersBufferForDistancesComputation(t,e,n),this.updateGPUTransformIndexesBufferForDistancesComputation(t,s,n)}refreshDataTexturesFromSplatBuffers(e){const s=this.getSplatCount(!0),t=this.lastBuildSplatCount,n=s-1;e?this.updateBaseDataFromSplatBuffers(t,n):(this.setupDataTextures(),this.updateBaseDataFromSplatBuffers()),this.updateDataTexturesFromBaseData(t,n),this.updateVisibleRegion(e)}setupDataTextures(){const e=this.getMaxSplatCount(),s=this.getSplatCount(!0);this.disposeTextures();const t=(S,w)=>{const F=new N(4096,1024);for(;F.x*F.y*S<e*w;)F.y*=2;return F},n=S=>S>=1?nr:tr,o=S=>{const w=n(S),F=t(w,6);return{elementsPerTexelStored:w,texSize:F}};let i=this.getTargetCovarianceCompressionLevel();const r=0,a=this.getTargetSphericalHarmonicsCompressionLevel();let l,c,d;if(this.splatRenderMode===Le.ThreeD){const S=o(i);S.texSize.x*S.texSize.y>js&&i===0&&(i=1),l=new Float32Array(e*Tt)}else c=new Float32Array(e*3),d=new Float32Array(e*4);const u=new Float32Array(e*3),h=new Uint8Array(e*4);let f=Float32Array;a===1?f=Uint16Array:a===2&&(f=Uint8Array);const p=Je(this.minSphericalHarmonicsDegree),A=this.minSphericalHarmonicsDegree?new f(e*p):void 0,C=t(Qt,4),g=new Uint32Array(C.x*C.y*Qt);ye.updateCenterColorsPaddedData(0,s-1,u,h,g);const x=new Ue(g,C.x,C.y,Mt,ot);if(x.internalFormat="RGBA32UI",x.needsUpdate=!0,this.material.uniforms.centersColorsTexture.value=x,this.material.uniforms.centersColorsTextureSize.value.copy(C),this.material.uniformsNeedUpdate=!0,this.splatDataTextures={baseData:{covariances:l,scales:c,rotations:d,centers:u,colors:h,sphericalHarmonics:A},centerColors:{data:g,texture:x,size:C}},this.splatRenderMode===Le.ThreeD){const S=o(i),w=S.elementsPerTexelStored,F=S.texSize;let b=i>=1?Uint32Array:Float32Array;const D=i>=1?or:sr,M=new b(F.x*F.y*D);i===0?M.set(l):ye.updatePaddedCompressedCovariancesTextureData(l,M,0,0,l.length);let L;if(i>=1)L=new Ue(M,F.x,F.y,Mt,ot),L.internalFormat="RGBA32UI",this.material.uniforms.covariancesTextureHalfFloat.value=L;else{L=new Ue(M,F.x,F.y,Bt,fs),this.material.uniforms.covariancesTexture.value=L;const R=new Ue(new Uint32Array(32),2,2,Mt,ot);R.internalFormat="RGBA32UI",this.material.uniforms.covariancesTextureHalfFloat.value=R,R.needsUpdate=!0}L.needsUpdate=!0,this.material.uniforms.covariancesAreHalfFloat.value=i>=1?1:0,this.material.uniforms.covariancesTextureSize.value.copy(F),this.splatDataTextures.covariances={data:M,texture:L,size:F,compressionLevel:i,elementsPerTexelStored:w,elementsPerTexelAllocated:D}}else{const w=t(_t,6);let F=Float32Array,b=fs;const D=new F(w.x*w.y*_t);ye.updateScaleRotationsPaddedData(0,s-1,c,d,D);const M=new Ue(D,w.x,w.y,Bt,b);M.needsUpdate=!0,this.material.uniforms.scaleRotationsTexture.value=M,this.material.uniforms.scaleRotationsTextureSize.value.copy(w),this.splatDataTextures.scaleRotations={data:D,texture:M,size:w,compressionLevel:r}}if(A){const S=a===2?Sn:yn;let w=p;w%2!==0&&w++;const F=4,b=Bt;let D=t(F,w);if(D.x*D.y<=js){const M=D.x*D.y*F,L=new f(M);for(let O=0;O<s;O++){const k=p*O,U=w*O;for(let _=0;_<p;_++)L[U+_]=A[k+_]}const R=new Ue(L,D.x,D.y,b,S);R.needsUpdate=!0,this.material.uniforms.sphericalHarmonicsTexture.value=R,this.splatDataTextures.sphericalHarmonics={componentCount:p,paddedComponentCount:w,data:L,textureCount:1,texture:R,size:D,compressionLevel:a,elementsPerTexel:F}}else{const M=p/3;w=M,w%2!==0&&w++,D=t(F,w);const L=D.x*D.y*F,R=[this.material.uniforms.sphericalHarmonicsTextureR,this.material.uniforms.sphericalHarmonicsTextureG,this.material.uniforms.sphericalHarmonicsTextureB],O=[],k=[];for(let U=0;U<3;U++){const _=new f(L);O.push(_);for(let Q=0;Q<s;Q++){const ee=p*Q,le=w*Q;if(M>=3){for(let V=0;V<3;V++)_[le+V]=A[ee+U*3+V];if(M>=8)for(let V=0;V<5;V++)_[le+3+V]=A[ee+9+U*5+V]}}const H=new Ue(_,D.x,D.y,b,S);k.push(H),H.needsUpdate=!0,R[U].value=H}this.material.uniforms.sphericalHarmonicsMultiTextureMode.value=1,this.splatDataTextures.sphericalHarmonics={componentCount:p,componentCountPerChannel:M,paddedComponentCount:w,data:O,textureCount:3,textures:k,size:D,compressionLevel:a,elementsPerTexel:F}}this.material.uniforms.sphericalHarmonicsTextureSize.value.copy(D),this.material.uniforms.sphericalHarmonics8BitMode.value=a===2?1:0;for(let M=0;M<this.scenes.length;M++){const L=this.scenes[M].splatBuffer;this.material.uniforms.sphericalHarmonics8BitCompressionRangeMin.value[M]=L.minSphericalHarmonicsCoeff,this.material.uniforms.sphericalHarmonics8BitCompressionRangeMax.value[M]=L.maxSphericalHarmonicsCoeff}this.material.uniformsNeedUpdate=!0}const B=t(Ws,4),y=new Uint32Array(B.x*B.y*Ws);for(let S=0;S<s;S++)y[S]=this.globalSplatIndexToSceneIndexMap[S];const E=new Ue(y,B.x,B.y,xn,ot);E.internalFormat="R32UI",E.needsUpdate=!0,this.material.uniforms.sceneIndexesTexture.value=E,this.material.uniforms.sceneIndexesTextureSize.value.copy(B),this.material.uniformsNeedUpdate=!0,this.splatDataTextures.sceneIndexes={data:y,texture:E,size:B},this.material.uniforms.sceneCount.value=this.scenes.length}updateBaseDataFromSplatBuffers(e,s){const t=this.splatDataTextures.covariances,n=t?t.compressionLevel:void 0,o=this.splatDataTextures.scaleRotations,i=o?o.compressionLevel:void 0,r=this.splatDataTextures.sphericalHarmonics,a=r?r.compressionLevel:0;this.fillSplatDataArrays(this.splatDataTextures.baseData.covariances,this.splatDataTextures.baseData.scales,this.splatDataTextures.baseData.rotations,this.splatDataTextures.baseData.centers,this.splatDataTextures.baseData.colors,this.splatDataTextures.baseData.sphericalHarmonics,void 0,n,i,a,e,s,e)}updateDataTexturesFromBaseData(e,s){const t=this.splatDataTextures.covariances,n=t?t.compressionLevel:void 0,o=this.splatDataTextures.scaleRotations,i=o?o.compressionLevel:void 0,r=this.splatDataTextures.sphericalHarmonics,a=r?r.compressionLevel:0,l=this.splatDataTextures.centerColors,c=l.data,d=l.texture;ye.updateCenterColorsPaddedData(e,s,this.splatDataTextures.baseData.centers,this.splatDataTextures.baseData.colors,c);const u=this.renderer?this.renderer.properties.get(d):null;if(!u||!u.__webglTexture?d.needsUpdate=!0:this.updateDataTexture(c,l.texture,l.size,u,Qt,er,4,e,s),t){const g=t.texture,x=e*Tt,B=s*Tt;if(n===0)for(let E=x;E<=B;E++){const S=this.splatDataTextures.baseData.covariances[E];t.data[E]=S}else ye.updatePaddedCompressedCovariancesTextureData(this.splatDataTextures.baseData.covariances,t.data,e*t.elementsPerTexelAllocated,x,B);const y=this.renderer?this.renderer.properties.get(g):null;!y||!y.__webglTexture?g.needsUpdate=!0:n===0?this.updateDataTexture(t.data,t.texture,t.size,y,t.elementsPerTexelStored,Tt,4,e,s):this.updateDataTexture(t.data,t.texture,t.size,y,t.elementsPerTexelAllocated,t.elementsPerTexelAllocated,2,e,s)}if(o){const g=o.data,x=o.texture,B=6,y=i===0?4:2;ye.updateScaleRotationsPaddedData(e,s,this.splatDataTextures.baseData.scales,this.splatDataTextures.baseData.rotations,g);const E=this.renderer?this.renderer.properties.get(x):null;!E||!E.__webglTexture?x.needsUpdate=!0:this.updateDataTexture(g,o.texture,o.size,E,_t,B,y,e,s)}const h=this.splatDataTextures.baseData.sphericalHarmonics;if(h){let g=4;a===1?g=2:a===2&&(g=1);const x=(E,S,w,F,b)=>{const D=this.renderer?this.renderer.properties.get(E):null;!D||!D.__webglTexture?E.needsUpdate=!0:this.updateDataTexture(F,E,S,D,w,b,g,e,s)},B=r.componentCount,y=r.paddedComponentCount;if(r.textureCount===1){const E=r.data;for(let S=e;S<=s;S++){const w=B*S,F=y*S;for(let b=0;b<B;b++)E[F+b]=h[w+b]}x(r.texture,r.size,r.elementsPerTexel,E,y)}else{const E=r.componentCountPerChannel;for(let S=0;S<3;S++){const w=r.data[S];for(let F=e;F<=s;F++){const b=B*F,D=y*F;if(E>=3){for(let M=0;M<3;M++)w[D+M]=h[b+S*3+M];if(E>=8)for(let M=0;M<5;M++)w[D+3+M]=h[b+9+S*5+M]}}x(r.textures[S],r.size,r.elementsPerTexel,w,y)}}}const f=this.splatDataTextures.sceneIndexes,p=f.data;for(let g=this.lastBuildSplatCount;g<=s;g++)p[g]=this.globalSplatIndexToSceneIndexMap[g];const A=f.texture,C=this.renderer?this.renderer.properties.get(A):null;!C||!C.__webglTexture?A.needsUpdate=!0:this.updateDataTexture(p,f.texture,f.size,C,1,1,1,this.lastBuildSplatCount,s)}getTargetCovarianceCompressionLevel(){return this.halfPrecisionCovariancesOnGPU?1:0}getTargetSphericalHarmonicsCompressionLevel(){return Math.max(1,this.getMaximumSplatBufferCompressionLevel())}getMaximumSplatBufferCompressionLevel(){let e;for(let s=0;s<this.scenes.length;s++){const n=this.getScene(s).splatBuffer;(s===0||n.compressionLevel>e)&&(e=n.compressionLevel)}return e}getMinimumSplatBufferCompressionLevel(){let e;for(let s=0;s<this.scenes.length;s++){const n=this.getScene(s).splatBuffer;(s===0||n.compressionLevel<e)&&(e=n.compressionLevel)}return e}static computeTextureUpdateRegion(e,s,t,n,o){const i=o/n,r=e*i,a=Math.floor(r/t),l=a*t*n,c=s*i,d=Math.floor(c/t),u=d*t*n+t*n;return{dataStart:l,dataEnd:u,startRow:a,endRow:d}}updateDataTexture(e,s,t,n,o,i,r,a,l){const c=this.renderer.getContext(),d=ye.computeTextureUpdateRegion(a,l,t.x,o,i),u=d.dataEnd-d.dataStart,h=new e.constructor(e.buffer,d.dataStart*r,u),f=d.endRow-d.startRow+1,p=this.webGLUtils.convert(s.type),A=this.webGLUtils.convert(s.format,s.colorSpace),C=c.getParameter(c.TEXTURE_BINDING_2D);c.bindTexture(c.TEXTURE_2D,n.__webglTexture),c.texSubImage2D(c.TEXTURE_2D,0,0,d.startRow,t.x,f,A,p,h),c.bindTexture(c.TEXTURE_2D,C)}static updatePaddedCompressedCovariancesTextureData(e,s,t,n,o){let i=new DataView(s.buffer),r=t,a=0;for(let l=n;l<=o;l+=2)i.setUint16(r*2,e[l],!0),i.setUint16(r*2+2,e[l+1],!0),r+=2,a++,a>=3&&(r+=2,a=0)}static updateCenterColorsPaddedData(e,s,t,n,o){for(let i=e;i<=s;i++){const r=i*4,a=i*3,l=i*4;o[l]=kn(n,r),o[l+1]=Pt(t[a]),o[l+2]=Pt(t[a+1]),o[l+3]=Pt(t[a+2])}}static updateScaleRotationsPaddedData(e,s,t,n,o){for(let r=e;r<=s;r++){const a=r*3,l=r*4,c=r*6;o[c]=t[a],o[c+1]=t[a+1],o[c+2]=t[a+2],o[c+3]=n[l],o[c+4]=n[l+1],o[c+5]=n[l+2]}}updateVisibleRegion(e){const s=this.getSplatCount(!0),t=new v;if(!e){const o=new v;this.scenes.forEach(i=>{o.add(i.splatBuffer.sceneCenter)}),o.multiplyScalar(1/this.scenes.length),this.calculatedSceneCenter.copy(o),this.material.uniforms.sceneCenter.value.copy(this.calculatedSceneCenter),this.material.uniformsNeedUpdate=!0}const n=e?this.lastBuildSplatCount:0;for(let o=n;o<s;o++){this.getSplatCenter(o,t,!0);const i=t.sub(this.calculatedSceneCenter).length();i>this.maxSplatDistanceFromSceneCenter&&(this.maxSplatDistanceFromSceneCenter=i)}this.maxSplatDistanceFromSceneCenter-this.visibleRegionBufferRadius>Ks&&(this.visibleRegionBufferRadius=this.maxSplatDistanceFromSceneCenter,this.visibleRegionRadius=Math.max(this.visibleRegionBufferRadius-Ks,0)),this.finalBuild&&(this.visibleRegionRadius=this.visibleRegionBufferRadius=this.maxSplatDistanceFromSceneCenter),this.updateVisibleRegionFadeDistance()}updateVisibleRegionFadeDistance(e=ht.Default){const s=rr*this.sceneFadeInRateMultiplier,t=ir*this.sceneFadeInRateMultiplier,n=this.finalBuild?s:t,o=e===ht.Default?n:t;this.visibleRegionFadeStartRadius=(this.visibleRegionRadius-this.visibleRegionFadeStartRadius)*o+this.visibleRegionFadeStartRadius;const r=(this.visibleRegionBufferRadius>0?this.visibleRegionFadeStartRadius/this.visibleRegionBufferRadius:0)>.99,a=r||e===ht.Instant?1:0;this.material.uniforms.visibleRegionFadeStartRadius.value=this.visibleRegionFadeStartRadius,this.material.uniforms.visibleRegionRadius.value=this.visibleRegionRadius,this.material.uniforms.firstRenderTime.value=this.firstRenderTime,this.material.uniforms.currentTime.value=performance.now(),this.material.uniforms.fadeInComplete.value=a,this.material.uniformsNeedUpdate=!0,this.visibleRegionChanging=!r}updateRenderIndexes(e,s){const t=this.geometry;t.attributes.splatIndex.set(e),t.attributes.splatIndex.needsUpdate=!0,s>0&&this.firstRenderTime===-1&&(this.firstRenderTime=performance.now()),t.instanceCount=s,t.setDrawRange(0,s)}updateTransforms(){for(let e=0;e<this.scenes.length;e++)this.getScene(e).updateTransform(this.dynamicMode)}updateUniforms=(function(){const e=new N;return function(s,t,n,o,i,r){if(this.getSplatCount()>0){if(e.set(s.x*this.devicePixelRatio,s.y*this.devicePixelRatio),this.material.uniforms.viewport.value.copy(e),this.material.uniforms.basisViewport.value.set(1/e.x,1/e.y),this.material.uniforms.focal.value.set(t,n),this.material.uniforms.orthographicMode.value=o?1:0,this.material.uniforms.orthoZoom.value=i,this.material.uniforms.inverseFocalAdjustment.value=r,this.dynamicMode)for(let l=0;l<this.scenes.length;l++)this.material.uniforms.transforms.value[l].copy(this.getScene(l).transform);if(this.enableOptionalEffects)for(let l=0;l<this.scenes.length;l++)this.material.uniforms.sceneOpacity.value[l]=re(this.getScene(l).opacity,0,1),this.material.uniforms.sceneVisibility.value[l]=this.getScene(l).visible?1:0,this.material.uniformsNeedUpdate=!0;this.material.uniformsNeedUpdate=!0}}})();setSplatScale(e=1){this.splatScale=e,this.material.uniforms.splatScale.value=e,this.material.uniformsNeedUpdate=!0}getSplatScale(){return this.splatScale}setPointCloudModeEnabled(e){this.pointCloudModeEnabled=e,this.material.uniforms.pointCloudModeEnabled.value=e?1:0,this.material.uniformsNeedUpdate=!0}getPointCloudModeEnabled(){return this.pointCloudModeEnabled}getSplatDataTextures(){return this.splatDataTextures}getSplatCount(e=!1){return e?ye.getTotalSplatCountForScenes(this.scenes):this.lastBuildSplatCount}static getTotalSplatCountForScenes(e){let s=0;for(let t of e)t&&t.splatBuffer&&(s+=t.splatBuffer.getSplatCount());return s}static getTotalSplatCountForSplatBuffers(e){let s=0;for(let t of e)s+=t.getSplatCount();return s}getMaxSplatCount(){return ye.getTotalMaxSplatCountForScenes(this.scenes)}static getTotalMaxSplatCountForScenes(e){let s=0;for(let t of e)t&&t.splatBuffer&&(s+=t.splatBuffer.getMaxSplatCount());return s}static getTotalMaxSplatCountForSplatBuffers(e){let s=0;for(let t of e)s+=t.getMaxSplatCount();return s}disposeDistancesComputationGPUResources(){if(!this.renderer)return;const e=this.renderer.getContext();this.distancesTransformFeedback.vao&&(e.deleteVertexArray(this.distancesTransformFeedback.vao),this.distancesTransformFeedback.vao=null),this.distancesTransformFeedback.program&&(e.deleteProgram(this.distancesTransformFeedback.program),e.deleteShader(this.distancesTransformFeedback.vertexShader),e.deleteShader(this.distancesTransformFeedback.fragmentShader),this.distancesTransformFeedback.program=null,this.distancesTransformFeedback.vertexShader=null,this.distancesTransformFeedback.fragmentShader=null),this.disposeDistancesComputationGPUBufferResources(),this.distancesTransformFeedback.id&&(e.deleteTransformFeedback(this.distancesTransformFeedback.id),this.distancesTransformFeedback.id=null)}disposeDistancesComputationGPUBufferResources(){if(!this.renderer)return;const e=this.renderer.getContext();this.distancesTransformFeedback.centersBuffer&&(this.distancesTransformFeedback.centersBuffer=null,e.deleteBuffer(this.distancesTransformFeedback.centersBuffer)),this.distancesTransformFeedback.outDistancesBuffer&&(e.deleteBuffer(this.distancesTransformFeedback.outDistancesBuffer),this.distancesTransformFeedback.outDistancesBuffer=null)}setRenderer(e){if(e!==this.renderer){this.renderer=e;const s=this.renderer.getContext(),t=new Jo(s),n=new Zo(s,t,{});if(t.init(n),this.webGLUtils=new In(s,t),this.enableDistancesComputationOnGPU&&this.getSplatCount()>0){this.setupDistancesComputationTransformFeedback();const{centers:o,sceneIndexes:i}=this.getDataForDistancesComputation(0,this.getSplatCount()-1);this.refreshGPUBuffersForDistancesComputation(o,i)}}}setupDistancesComputationTransformFeedback=(function(){let e;return function(){const s=this.getMaxSplatCount();if(!this.renderer)return;const t=this.lastRenderer!==this.renderer,n=e!==s;if(!t&&!n)return;t?this.disposeDistancesComputationGPUResources():n&&this.disposeDistancesComputationGPUBufferResources();const o=this.renderer.getContext(),i=(u,h,f)=>{const p=u.createShader(h);if(!p)return console.error("Fatal error: gl could not create a shader object."),null;if(u.shaderSource(p,f),u.compileShader(p),!u.getShaderParameter(p,u.COMPILE_STATUS)){let C="unknown";h===u.VERTEX_SHADER?C="vertex shader":h===u.FRAGMENT_SHADER&&(C="fragement shader");const g=u.getShaderInfoLog(p);return console.error("Failed to compile "+C+" with these errors:"+g),u.deleteShader(p),null}return p};let r;this.integerBasedDistancesComputation?(r=`#version 300 es
                in ivec4 center;
                flat out int distance;`,this.dynamicMode?r+=`
                        in uint sceneIndex;
                        uniform ivec4 transforms[${Y.MaxScenes}];
                        void main(void) {
                            ivec4 transform = transforms[sceneIndex];
                            distance = center.x * transform.x + center.y * transform.y + center.z * transform.z + transform.w * center.w;
                        }
                    `:r+=`
                        uniform ivec3 modelViewProj;
                        void main(void) {
                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;
                        }
                    `):(r=`#version 300 es
                in vec4 center;
                flat out float distance;`,this.dynamicMode?r+=`
                        in uint sceneIndex;
                        uniform mat4 transforms[${Y.MaxScenes}];
                        void main(void) {
                            vec4 transformedCenter = transforms[sceneIndex] * vec4(center.xyz, 1.0);
                            distance = transformedCenter.z;
                        }
                    `:r+=`
                        uniform vec3 modelViewProj;
                        void main(void) {
                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;
                        }
                    `);const a=`#version 300 es
                precision lowp float;
                out vec4 fragColor;
                void main(){}
            `,l=o.getParameter(o.VERTEX_ARRAY_BINDING),c=o.getParameter(o.CURRENT_PROGRAM),d=c?o.getProgramParameter(c,o.DELETE_STATUS):!1;if(t&&(this.distancesTransformFeedback.vao=o.createVertexArray()),o.bindVertexArray(this.distancesTransformFeedback.vao),t){const u=o.createProgram(),h=i(o,o.VERTEX_SHADER,r),f=i(o,o.FRAGMENT_SHADER,a);if(!h||!f)throw new Error("Could not compile shaders for distances computation on GPU.");if(o.attachShader(u,h),o.attachShader(u,f),o.transformFeedbackVaryings(u,["distance"],o.SEPARATE_ATTRIBS),o.linkProgram(u),!o.getProgramParameter(u,o.LINK_STATUS)){const A=o.getProgramInfoLog(u);throw console.error("Fatal error: Failed to link program: "+A),o.deleteProgram(u),o.deleteShader(f),o.deleteShader(h),new Error("Could not link shaders for distances computation on GPU.")}this.distancesTransformFeedback.program=u,this.distancesTransformFeedback.vertexShader=h,this.distancesTransformFeedback.vertexShader=f}if(o.useProgram(this.distancesTransformFeedback.program),this.distancesTransformFeedback.centersLoc=o.getAttribLocation(this.distancesTransformFeedback.program,"center"),this.dynamicMode){this.distancesTransformFeedback.sceneIndexesLoc=o.getAttribLocation(this.distancesTransformFeedback.program,"sceneIndex");for(let u=0;u<this.scenes.length;u++)this.distancesTransformFeedback.transformsLocs[u]=o.getUniformLocation(this.distancesTransformFeedback.program,`transforms[${u}]`)}else this.distancesTransformFeedback.modelViewProjLoc=o.getUniformLocation(this.distancesTransformFeedback.program,"modelViewProj");(t||n)&&(this.distancesTransformFeedback.centersBuffer=o.createBuffer(),o.bindBuffer(o.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),o.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),this.integerBasedDistancesComputation?o.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,4,o.INT,0,0):o.vertexAttribPointer(this.distancesTransformFeedback.centersLoc,4,o.FLOAT,!1,0,0),this.dynamicMode&&(this.distancesTransformFeedback.sceneIndexesBuffer=o.createBuffer(),o.bindBuffer(o.ARRAY_BUFFER,this.distancesTransformFeedback.sceneIndexesBuffer),o.enableVertexAttribArray(this.distancesTransformFeedback.sceneIndexesLoc),o.vertexAttribIPointer(this.distancesTransformFeedback.sceneIndexesLoc,1,o.UNSIGNED_INT,0,0))),(t||n)&&(this.distancesTransformFeedback.outDistancesBuffer=o.createBuffer()),o.bindBuffer(o.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),o.bufferData(o.ARRAY_BUFFER,s*4,o.STATIC_READ),t&&(this.distancesTransformFeedback.id=o.createTransformFeedback()),o.bindTransformFeedback(o.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),o.bindBufferBase(o.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),c&&d!==!0&&o.useProgram(c),l&&o.bindVertexArray(l),this.lastRenderer=this.renderer,e=s}})();updateGPUCentersBufferForDistancesComputation(e,s,t){if(!this.renderer)return;const n=this.renderer.getContext(),o=n.getParameter(n.VERTEX_ARRAY_BINDING);n.bindVertexArray(this.distancesTransformFeedback.vao);const i=this.integerBasedDistancesComputation?Uint32Array:Float32Array,r=16,a=t*r;if(n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),e)n.bufferSubData(n.ARRAY_BUFFER,a,s);else{const l=new i(this.getMaxSplatCount()*r);l.set(s),n.bufferData(n.ARRAY_BUFFER,l,n.STATIC_DRAW)}n.bindBuffer(n.ARRAY_BUFFER,null),o&&n.bindVertexArray(o)}updateGPUTransformIndexesBufferForDistancesComputation(e,s,t){if(!this.renderer||!this.dynamicMode)return;const n=this.renderer.getContext(),o=n.getParameter(n.VERTEX_ARRAY_BINDING);n.bindVertexArray(this.distancesTransformFeedback.vao);const i=t*4;if(n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.sceneIndexesBuffer),e)n.bufferSubData(n.ARRAY_BUFFER,i,s);else{const r=new Uint32Array(this.getMaxSplatCount()*4);r.set(s),n.bufferData(n.ARRAY_BUFFER,r,n.STATIC_DRAW)}n.bindBuffer(n.ARRAY_BUFFER,null),o&&n.bindVertexArray(o)}getSceneIndexes(e,s){let t;const n=s-e+1;t=new Uint32Array(n);for(let o=e;o<=s;o++)t[o]=this.globalSplatIndexToSceneIndexMap[o];return t}fillTransformsArray=(function(){const e=[];return function(s){e.length!==s.length&&(e.length=s.length);for(let t=0;t<this.scenes.length;t++){const o=this.getScene(t).transform.elements;for(let i=0;i<16;i++)e[t*16+i]=o[i]}s.set(e)}})();computeDistancesOnGPU=(function(){const e=new J;return function(s,t){if(!this.renderer)return;const n=this.renderer.getContext(),o=n.getParameter(n.VERTEX_ARRAY_BINDING),i=n.getParameter(n.CURRENT_PROGRAM),r=i?n.getProgramParameter(i,n.DELETE_STATUS):!1;if(n.bindVertexArray(this.distancesTransformFeedback.vao),n.useProgram(this.distancesTransformFeedback.program),n.enable(n.RASTERIZER_DISCARD),this.dynamicMode)for(let c=0;c<this.scenes.length;c++)if(e.copy(this.getScene(c).transform),e.premultiply(s),this.integerBasedDistancesComputation){const d=ye.getIntegerMatrixArray(e),u=[d[2],d[6],d[10],d[14]];n.uniform4i(this.distancesTransformFeedback.transformsLocs[c],u[0],u[1],u[2],u[3])}else n.uniformMatrix4fv(this.distancesTransformFeedback.transformsLocs[c],!1,e.elements);else if(this.integerBasedDistancesComputation){const c=ye.getIntegerMatrixArray(s),d=[c[2],c[6],c[10]];n.uniform3i(this.distancesTransformFeedback.modelViewProjLoc,d[0],d[1],d[2])}else{const c=[s.elements[2],s.elements[6],s.elements[10]];n.uniform3f(this.distancesTransformFeedback.modelViewProjLoc,c[0],c[1],c[2])}n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),n.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),this.integerBasedDistancesComputation?n.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,4,n.INT,0,0):n.vertexAttribPointer(this.distancesTransformFeedback.centersLoc,4,n.FLOAT,!1,0,0),this.dynamicMode&&(n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.sceneIndexesBuffer),n.enableVertexAttribArray(this.distancesTransformFeedback.sceneIndexesLoc),n.vertexAttribIPointer(this.distancesTransformFeedback.sceneIndexesLoc,1,n.UNSIGNED_INT,0,0)),n.bindTransformFeedback(n.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),n.bindBufferBase(n.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),n.beginTransformFeedback(n.POINTS),n.drawArrays(n.POINTS,0,this.getSplatCount()),n.endTransformFeedback(),n.bindBufferBase(n.TRANSFORM_FEEDBACK_BUFFER,0,null),n.bindTransformFeedback(n.TRANSFORM_FEEDBACK,null),n.disable(n.RASTERIZER_DISCARD);const a=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0);n.flush();const l=new Promise(c=>{const d=()=>{if(this.disposed)c();else switch(n.clientWaitSync(a,0,0)){case n.TIMEOUT_EXPIRED:return this.computeDistancesOnGPUSyncTimeout=setTimeout(d),this.computeDistancesOnGPUSyncTimeout;case n.WAIT_FAILED:throw new Error("should never get here");default:this.computeDistancesOnGPUSyncTimeout=null,n.deleteSync(a);const p=n.getParameter(n.VERTEX_ARRAY_BINDING);n.bindVertexArray(this.distancesTransformFeedback.vao),n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),n.getBufferSubData(n.ARRAY_BUFFER,0,t),n.bindBuffer(n.ARRAY_BUFFER,null),p&&n.bindVertexArray(p),c()}};this.computeDistancesOnGPUSyncTimeout=setTimeout(d)});return i&&r!==!0&&n.useProgram(i),o&&n.bindVertexArray(o),l}})();getLocalSplatParameters(e,s,t){t==null&&(t=!this.dynamicMode),s.splatBuffer=this.getSplatBufferForSplat(e),s.localIndex=this.getSplatLocalIndex(e),s.sceneTransform=t?this.getSceneTransformForSplat(e):null}fillSplatDataArrays(e,s,t,n,o,i,r,a=0,l=0,c=1,d,u,h=0,f){const p=new v;p.x=void 0,p.y=void 0,this.splatRenderMode===Le.ThreeD?p.z=void 0:p.z=1;const A=new J;let C=0,g=this.scenes.length-1;f!=null&&f>=0&&f<=this.scenes.length&&(C=f,g=f);for(let x=C;x<=g;x++){r==null&&(r=!this.dynamicMode);const B=this.getScene(x),y=B.splatBuffer;let E;if(r&&(this.getSceneTransform(x,A),E=A),e&&y.fillSplatCovarianceArray(e,E,d,u,h,a),s||t){if(!s||!t)throw new Error('SplatMesh::fillSplatDataArrays() -> "scales" and "rotations" must both be valid.');y.fillSplatScaleRotationArray(s,t,E,d,u,h,l,p)}n&&y.fillSplatCenterArray(n,E,d,u,h),o&&y.fillSplatColorArray(o,B.minimumAlpha,d,u,h),i&&y.fillSphericalHarmonicsArray(i,this.minSphericalHarmonicsDegree,E,d,u,h,c),h+=y.getSplatCount()}}getIntegerCenters(e,s,t=!1){const n=s-e+1,o=new Float32Array(n*3);this.fillSplatDataArrays(null,null,null,o,null,null,void 0,void 0,void 0,void 0,e);let i,r=t?4:3;i=new Int32Array(n*r);for(let a=0;a<n;a++){for(let l=0;l<3;l++)i[a*r+l]=Math.round(o[a*3+l]*1e3);t&&(i[a*r+3]=1e3)}return i}getFloatCenters(e,s,t=!1){const n=s-e+1,o=new Float32Array(n*3);if(this.fillSplatDataArrays(null,null,null,o,null,null,void 0,void 0,void 0,void 0,e),!t)return o;let i=new Float32Array(n*4);for(let r=0;r<n;r++){for(let a=0;a<3;a++)i[r*4+a]=o[r*3+a];i[r*4+3]=1}return i}getSplatCenter=(function(){const e={};return function(s,t,n){this.getLocalSplatParameters(s,e,n),e.splatBuffer.getSplatCenter(e.localIndex,t,e.sceneTransform)}})();getSplatScaleAndRotation=(function(){const e={},s=new v;return function(t,n,o,i){this.getLocalSplatParameters(t,e,i),s.x=void 0,s.y=void 0,s.z=void 0,this.splatRenderMode===Le.TwoD&&(s.z=0),e.splatBuffer.getSplatScaleAndRotation(e.localIndex,n,o,e.sceneTransform,s)}})();getSplatColor=(function(){const e={};return function(s,t){this.getLocalSplatParameters(s,e),e.splatBuffer.getSplatColor(e.localIndex,t)}})();getSceneTransform(e,s){const t=this.getScene(e);t.updateTransform(this.dynamicMode),s.copy(t.transform)}getScene(e){if(e<0||e>=this.scenes.length)throw new Error("SplatMesh::getScene() -> Invalid scene index.");return this.scenes[e]}getSceneCount(){return this.scenes.length}getSplatBufferForSplat(e){return this.getScene(this.globalSplatIndexToSceneIndexMap[e]).splatBuffer}getSceneIndexForSplat(e){return this.globalSplatIndexToSceneIndexMap[e]}getSceneTransformForSplat(e){return this.getScene(this.globalSplatIndexToSceneIndexMap[e]).transform}getSplatLocalIndex(e){return this.globalSplatIndexToLocalSplatIndexMap[e]}static getIntegerMatrixArray(e){const s=e.elements,t=[];for(let n=0;n<16;n++)t[n]=Math.round(s[n]*1e3);return t}computeBoundingBox(e=!1,s){let t=this.getSplatCount();if(s!=null){if(s<0||s>=this.scenes.length)throw new Error("SplatMesh::computeBoundingBox() -> Invalid scene index.");t=this.scenes[s].splatBuffer.getSplatCount()}const n=new Float32Array(t*3);this.fillSplatDataArrays(null,null,null,n,null,null,e,void 0,void 0,void 0,void 0,s);const o=new v,i=new v;for(let r=0;r<t;r++){const a=r*3,l=n[a],c=n[a+1],d=n[a+2];(r===0||l<o.x)&&(o.x=l),(r===0||c<o.y)&&(o.y=c),(r===0||d<o.z)&&(o.z=d),(r===0||l>i.x)&&(i.x=l),(r===0||c>i.y)&&(i.y=c),(r===0||d>i.z)&&(i.z=d)}return new nt(o,i)}}var ar="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",Ys="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",lr="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",cr="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";function dr(m){let e,s,t,n,o,i,r,a,l,c,d,u,h,f,p,A,C,g,x,B;function y(E,S,w,F,b,D,M){const L=performance.now();if(!t&&(new Uint32Array(s,r,b.byteLength/B.BytesPerInt).set(b),new Float32Array(s,c,M.byteLength/B.BytesPerFloat).set(M),F)){let _;n?_=new Int32Array(s,d,D.byteLength/B.BytesPerInt):_=new Float32Array(s,d,D.byteLength/B.BytesPerFloat),_.set(D)}A||(A=new Uint32Array(g)),new Float32Array(s,p,16).set(w),new Uint32Array(s,h,g).set(A),e.exports.sortIndexes(r,f,d,u,h,p,a,l,c,g,E,S,i,F,n,o);const R={sortDone:!0,splatSortCount:E,splatRenderCount:S,sortTime:0};if(!t){const k=new Uint32Array(s,a,S);(!C||C.length<S)&&(C=new Uint32Array(S)),C.set(k),R.sortedIndexes=C}const O=performance.now();R.sortTime=O-L,m.postMessage(R)}m.onmessage=E=>{if(E.data.centers)centers=E.data.centers,sceneIndexes=E.data.sceneIndexes,n?new Int32Array(s,f+E.data.range.from*B.BytesPerInt*4,E.data.range.count*4).set(new Int32Array(centers)):new Float32Array(s,f+E.data.range.from*B.BytesPerFloat*4,E.data.range.count*4).set(new Float32Array(centers)),o&&new Uint32Array(s,l+E.data.range.from*4,E.data.range.count).set(new Uint32Array(sceneIndexes)),x=E.data.range.from+E.data.range.count;else if(E.data.sort){const S=Math.min(E.data.sort.splatRenderCount||0,x),w=Math.min(E.data.sort.splatSortCount||0,x),F=E.data.sort.usePrecomputedDistances;let b,D,M;t||(b=E.data.sort.indexesToSort,M=E.data.sort.transforms,F&&(D=E.data.sort.precomputedDistances)),y(w,S,E.data.sort.modelViewProj,F,b,D,M)}else if(E.data.init){B=E.data.init.Constants,i=E.data.init.splatCount,t=E.data.init.useSharedMemory,n=E.data.init.integerBasedSort,o=E.data.init.dynamicMode,g=E.data.init.distanceMapRange,x=0;const S=n?B.BytesPerInt*4:B.BytesPerFloat*4,w=new Uint8Array(E.data.init.sorterWasmBytes),F=16*B.BytesPerFloat,b=i*B.BytesPerInt,D=i*S,M=F,L=n?i*B.BytesPerInt:i*B.BytesPerFloat,R=i*B.BytesPerInt,O=i*B.BytesPerInt,k=n?g*B.BytesPerInt*2:g*B.BytesPerFloat*2,U=o?i*B.BytesPerInt:0,_=o?B.MaxScenes*F:0,H=B.MemoryPageSize*32,Q=b+D+M+L+R+k+O+U+_+H,ee=Math.floor(Q/B.MemoryPageSize)+1,le={module:{},env:{memory:new WebAssembly.Memory({initial:ee,maximum:ee,shared:!0})}};WebAssembly.compile(w).then(V=>WebAssembly.instantiate(V,le)).then(V=>{e=V,r=0,f=r+b,p=f+D,d=p+M,u=d+L,h=u+R,a=h+k,l=a+O,c=l+U,s=le.env.memory.buffer,t?m.postMessage({sortSetupPhase1Complete:!0,indexesToSortBuffer:s,indexesToSortOffset:r,sortedIndexesBuffer:s,sortedIndexesOffset:a,precomputedDistancesBuffer:s,precomputedDistancesOffset:d,transformsBuffer:s,transformsOffset:c}):m.postMessage({sortSetupPhase1Complete:!0})})}}}function hr(m,e,s,t,n,o=Y.DefaultSplatSortDistanceMapPrecision){const i=new Worker(URL.createObjectURL(new Blob(["(",dr.toString(),")(self)"],{type:"application/javascript"})));let r=ar;const a=jt()?tn():null;!s&&!e?(r=Ys,a&&a.major<=16&&a.minor<4&&(r=cr)):s?e||a&&a.major<=16&&a.minor<4&&(r=lr):r=Ys;const l=atob(r),c=new Uint8Array(l.length);for(let d=0;d<l.length;d++)c[d]=l.charCodeAt(d);return i.postMessage({init:{sorterWasmBytes:c.buffer,splatCount:m,useSharedMemory:e,integerBasedSort:t,dynamicMode:n,distanceMapRange:1<<o,Constants:{BytesPerFloat:Y.BytesPerFloat,BytesPerInt:Y.BytesPerInt,MemoryPageSize:Y.MemoryPageSize,MaxScenes:Y.MaxScenes}}}),i}const je={None:0,VR:1,AR:2};class et{static createButton(e,s={}){const t=document.createElement("button");function n(){let l=null;async function c(h){h.addEventListener("end",d),await e.xr.setSession(h),t.textContent="EXIT VR",l=h}function d(){l.removeEventListener("end",d),t.textContent="ENTER VR",l=null}t.style.display="",t.style.cursor="pointer",t.style.left="calc(50% - 50px)",t.style.width="100px",t.textContent="ENTER VR";const u={...s,optionalFeatures:["local-floor","bounded-floor","layers",...s.optionalFeatures||[]]};t.onmouseenter=function(){t.style.opacity="1.0"},t.onmouseleave=function(){t.style.opacity="0.5"},t.onclick=function(){l===null?navigator.xr.requestSession("immersive-vr",u).then(c):(l.end(),navigator.xr.offerSession!==void 0&&navigator.xr.offerSession("immersive-vr",u).then(c).catch(h=>{console.warn(h)}))},navigator.xr.offerSession!==void 0&&navigator.xr.offerSession("immersive-vr",u).then(c).catch(h=>{console.warn(h)})}function o(){t.style.display="",t.style.cursor="auto",t.style.left="calc(50% - 75px)",t.style.width="150px",t.onmouseenter=null,t.onmouseleave=null,t.onclick=null}function i(){o(),t.textContent="VR NOT SUPPORTED"}function r(l){o(),console.warn("Exception when trying to call xr.isSessionSupported",l),t.textContent="VR NOT ALLOWED"}function a(l){l.style.position="absolute",l.style.bottom="20px",l.style.padding="12px 6px",l.style.border="1px solid #fff",l.style.borderRadius="4px",l.style.background="rgba(0,0,0,0.1)",l.style.color="#fff",l.style.font="normal 13px sans-serif",l.style.textAlign="center",l.style.opacity="0.5",l.style.outline="none",l.style.zIndex="999"}if("xr"in navigator)return t.id="VRButton",t.style.display="none",a(t),navigator.xr.isSessionSupported("immersive-vr").then(function(l){l?n():i(),l&&et.xrSessionIsGranted&&t.click()}).catch(r),t;{const l=document.createElement("a");return window.isSecureContext===!1?(l.href=document.location.href.replace(/^http:/,"https:"),l.innerHTML="WEBXR NEEDS HTTPS"):(l.href="https://immersiveweb.dev/",l.innerHTML="WEBXR NOT AVAILABLE"),l.style.left="calc(50% - 90px)",l.style.width="180px",l.style.textDecoration="none",a(l),l}}static registerSessionGrantedListener(){if(typeof navigator<"u"&&"xr"in navigator){if(/WebXRViewer\//i.test(navigator.userAgent))return;navigator.xr.addEventListener("sessiongranted",()=>{et.xrSessionIsGranted=!0})}}}et.xrSessionIsGranted=!1;et.registerSessionGrantedListener();class ur{static createButton(e,s={}){const t=document.createElement("button");function n(){if(s.domOverlay===void 0){const u=document.createElement("div");u.style.display="none",document.body.appendChild(u);const h=document.createElementNS("http://www.w3.org/2000/svg","svg");h.setAttribute("width",38),h.setAttribute("height",38),h.style.position="absolute",h.style.right="20px",h.style.top="20px",h.addEventListener("click",function(){l.end()}),u.appendChild(h);const f=document.createElementNS("http://www.w3.org/2000/svg","path");f.setAttribute("d","M 12,12 L 28,28 M 28,12 12,28"),f.setAttribute("stroke","#fff"),f.setAttribute("stroke-width",2),h.appendChild(f),s.optionalFeatures===void 0&&(s.optionalFeatures=[]),s.optionalFeatures.push("dom-overlay"),s.domOverlay={root:u}}let l=null;async function c(u){u.addEventListener("end",d),e.xr.setReferenceSpaceType("local"),await e.xr.setSession(u),t.textContent="STOP AR",s.domOverlay.root.style.display="",l=u}function d(){l.removeEventListener("end",d),t.textContent="START AR",s.domOverlay.root.style.display="none",l=null}t.style.display="",t.style.cursor="pointer",t.style.left="calc(50% - 50px)",t.style.width="100px",t.textContent="START AR",t.onmouseenter=function(){t.style.opacity="1.0"},t.onmouseleave=function(){t.style.opacity="0.5"},t.onclick=function(){l===null?navigator.xr.requestSession("immersive-ar",s).then(c):(l.end(),navigator.xr.offerSession!==void 0&&navigator.xr.offerSession("immersive-ar",s).then(c).catch(u=>{console.warn(u)}))},navigator.xr.offerSession!==void 0&&navigator.xr.offerSession("immersive-ar",s).then(c).catch(u=>{console.warn(u)})}function o(){t.style.display="",t.style.cursor="auto",t.style.left="calc(50% - 75px)",t.style.width="150px",t.onmouseenter=null,t.onmouseleave=null,t.onclick=null}function i(){o(),t.textContent="AR NOT SUPPORTED"}function r(l){o(),console.warn("Exception when trying to call xr.isSessionSupported",l),t.textContent="AR NOT ALLOWED"}function a(l){l.style.position="absolute",l.style.bottom="20px",l.style.padding="12px 6px",l.style.border="1px solid #fff",l.style.borderRadius="4px",l.style.background="rgba(0,0,0,0.1)",l.style.color="#fff",l.style.font="normal 13px sans-serif",l.style.textAlign="center",l.style.opacity="0.5",l.style.outline="none",l.style.zIndex="999"}if("xr"in navigator)return t.id="ARButton",t.style.display="none",a(t),navigator.xr.isSessionSupported("immersive-ar").then(function(l){l?n():i()}).catch(r),t;{const l=document.createElement("a");return window.isSecureContext===!1?(l.href=document.location.href.replace(/^http:/,"https:"),l.innerHTML="WEBXR NEEDS HTTPS"):(l.href="https://immersiveweb.dev/",l.innerHTML="WEBXR NOT AVAILABLE"),l.style.left="calc(50% - 90px)",l.style.width="180px",l.style.textDecoration="none",a(l),l}}}const Nt={Always:0,Never:2},pr=50,fr=.75,mr=15e5,Ar=10,gr=2.5,Cr=60;class rt{constructor(e={}){if(e.cameraUp||(e.cameraUp=[0,1,0]),this.cameraUp=new v().fromArray(e.cameraUp),e.initialCameraPosition||(e.initialCameraPosition=[0,10,15]),this.initialCameraPosition=new v().fromArray(e.initialCameraPosition),e.initialCameraLookAt||(e.initialCameraLookAt=[0,0,0]),this.initialCameraLookAt=new v().fromArray(e.initialCameraLookAt),this.dropInMode=e.dropInMode||!1,(e.selfDrivenMode===void 0||e.selfDrivenMode===null)&&(e.selfDrivenMode=!0),this.selfDrivenMode=e.selfDrivenMode&&!this.dropInMode,this.selfDrivenUpdateFunc=this.selfDrivenUpdate.bind(this),e.useBuiltInControls===void 0&&(e.useBuiltInControls=!0),this.useBuiltInControls=e.useBuiltInControls,this.rootElement=e.rootElement,this.ignoreDevicePixelRatio=e.ignoreDevicePixelRatio||!1,this.devicePixelRatio=this.ignoreDevicePixelRatio?1:window.devicePixelRatio||1,this.halfPrecisionCovariancesOnGPU=e.halfPrecisionCovariancesOnGPU||!1,this.threeScene=e.threeScene,this.renderer=e.renderer,this.camera=e.camera,this.gpuAcceleratedSort=e.gpuAcceleratedSort||!1,(e.integerBasedSort===void 0||e.integerBasedSort===null)&&(e.integerBasedSort=!0),this.integerBasedSort=e.integerBasedSort,(e.sharedMemoryForWorkers===void 0||e.sharedMemoryForWorkers===null)&&(e.sharedMemoryForWorkers=!0),this.sharedMemoryForWorkers=e.sharedMemoryForWorkers,this.dynamicScene=!!e.dynamicScene,this.antialiased=e.antialiased||!1,this.kernel2DSize=e.kernel2DSize===void 0?.3:e.kernel2DSize,this.webXRMode=e.webXRMode||je.None,this.webXRMode!==je.None&&(this.gpuAcceleratedSort=!1),this.webXRActive=!1,this.webXRSessionInit=e.webXRSessionInit||{},this.renderMode=e.renderMode||Nt.Always,this.sceneRevealMode=e.sceneRevealMode||ht.Default,this.focalAdjustment=e.focalAdjustment||1,this.maxScreenSpaceSplatSize=e.maxScreenSpaceSplatSize||1024,this.logLevel=e.logLevel||$e.None,this.sphericalHarmonicsDegree=e.sphericalHarmonicsDegree||0,this.enableOptionalEffects=e.enableOptionalEffects||!1,(e.enableSIMDInSort===void 0||e.enableSIMDInSort===null)&&(e.enableSIMDInSort=!0),this.enableSIMDInSort=e.enableSIMDInSort,(e.inMemoryCompressionLevel===void 0||e.inMemoryCompressionLevel===null)&&(e.inMemoryCompressionLevel=0),this.inMemoryCompressionLevel=e.inMemoryCompressionLevel,(e.optimizeSplatData===void 0||e.optimizeSplatData===null)&&(e.optimizeSplatData=!0),this.optimizeSplatData=e.optimizeSplatData,(e.freeIntermediateSplatData===void 0||e.freeIntermediateSplatData===null)&&(e.freeIntermediateSplatData=!1),this.freeIntermediateSplatData=e.freeIntermediateSplatData,jt()){const t=tn();t.major<17&&(this.enableSIMDInSort=!1),t.major<16&&(this.sharedMemoryForWorkers=!1)}(e.splatRenderMode===void 0||e.splatRenderMode===null)&&(e.splatRenderMode=Le.ThreeD),this.splatRenderMode=e.splatRenderMode,this.sceneFadeInRateMultiplier=e.sceneFadeInRateMultiplier||1,this.splatSortDistanceMapPrecision=e.splatSortDistanceMapPrecision||Y.DefaultSplatSortDistanceMapPrecision;const s=this.integerBasedSort?20:24;this.splatSortDistanceMapPrecision=re(this.splatSortDistanceMapPrecision,10,s),this.onSplatMeshChangedCallback=null,this.createSplatMesh(),this.controls=null,this.perspectiveControls=null,this.orthographicControls=null,this.orthographicCamera=null,this.perspectiveCamera=null,this.showMeshCursor=!1,this.showControlPlane=!1,this.showInfo=!1,this.sceneHelper=null,this.sortWorker=null,this.sortRunning=!1,this.splatRenderCount=0,this.splatSortCount=0,this.lastSplatSortCount=0,this.sortWorkerIndexesToSort=null,this.sortWorkerSortedIndexes=null,this.sortWorkerPrecomputedDistances=null,this.sortWorkerTransforms=null,this.preSortMessages=[],this.runAfterNextSort=[],this.selfDrivenModeRunning=!1,this.splatRenderReady=!1,this.raycaster=new Go,this.infoPanel=null,this.startInOrthographicMode=!1,this.currentFPS=0,this.lastSortTime=0,this.consecutiveRenderFrames=0,this.previousCameraTarget=new v,this.nextCameraTarget=new v,this.mousePosition=new N,this.mouseDownPosition=new N,this.mouseDownTime=null,this.resizeObserver=null,this.mouseMoveListener=null,this.mouseDownListener=null,this.mouseUpListener=null,this.keyDownListener=null,this.sortPromise=null,this.sortPromiseResolver=null,this.splatSceneDownloadPromises={},this.splatSceneDownloadAndBuildPromise=null,this.splatSceneRemovalPromise=null,this.loadingSpinner=new as(null,this.rootElement||document.body),this.loadingSpinner.hide(),this.loadingProgressBar=new Uo(this.rootElement||document.body),this.loadingProgressBar.hide(),this.infoPanel=new zo(this.rootElement||document.body),this.infoPanel.hide(),this.usingExternalCamera=!!(this.dropInMode||this.camera),this.usingExternalRenderer=!!(this.dropInMode||this.renderer),this.initialized=!1,this.disposing=!1,this.disposed=!1,this.disposePromise=null,this.dropInMode||this.init()}createSplatMesh(){this.splatMesh=new ye(this.splatRenderMode,this.dynamicScene,this.enableOptionalEffects,this.halfPrecisionCovariancesOnGPU,this.devicePixelRatio,this.gpuAcceleratedSort,this.integerBasedSort,this.antialiased,this.maxScreenSpaceSplatSize,this.logLevel,this.sphericalHarmonicsDegree,this.sceneFadeInRateMultiplier,this.kernel2DSize),this.splatMesh.frustumCulled=!1,this.onSplatMeshChangedCallback&&this.onSplatMeshChangedCallback()}init(){this.initialized||(this.rootElement||(this.usingExternalRenderer?this.rootElement=this.renderer.domElement||document.body:(this.rootElement=document.createElement("div"),this.rootElement.style.width="100%",this.rootElement.style.height="100%",this.rootElement.style.position="absolute",document.body.appendChild(this.rootElement))),this.setupCamera(),this.setupRenderer(),this.setupWebXR(this.webXRSessionInit),this.setupControls(),this.setupEventHandlers(),this.threeScene=this.threeScene||new An,this.sceneHelper=new ct(this.threeScene),this.sceneHelper.setupMeshCursor(),this.sceneHelper.setupFocusMarker(),this.sceneHelper.setupControlPlane(),this.loadingProgressBar.setContainer(this.rootElement),this.loadingSpinner.setContainer(this.rootElement),this.infoPanel.setContainer(this.rootElement),this.initialized=!0)}setupCamera(){if(!this.usingExternalCamera){const e=new N;this.getRenderDimensions(e),this.perspectiveCamera=new gn(pr,e.x/e.y,.1,1e3),this.orthographicCamera=new Js(e.x/-2,e.x/2,e.y/2,e.y/-2,.1,1e3),this.camera=this.startInOrthographicMode?this.orthographicCamera:this.perspectiveCamera,this.camera.position.copy(this.initialCameraPosition),this.camera.up.copy(this.cameraUp).normalize(),this.camera.lookAt(this.initialCameraLookAt)}}setupRenderer(){if(!this.usingExternalRenderer){const e=new N;this.getRenderDimensions(e),this.renderer=new Cn({antialias:!1,precision:"highp"}),this.renderer.setPixelRatio(this.devicePixelRatio),this.renderer.autoClear=!0,this.renderer.setClearColor(new Et(0),0),this.renderer.setSize(e.x,e.y),this.resizeObserver=new ResizeObserver(()=>{this.getRenderDimensions(e),this.renderer.setSize(e.x,e.y),this.forceRenderNextFrame()}),this.resizeObserver.observe(this.rootElement),this.rootElement.appendChild(this.renderer.domElement)}}setupWebXR(e){this.webXRMode&&(this.webXRMode===je.VR?this.rootElement.appendChild(et.createButton(this.renderer,e)):this.webXRMode===je.AR&&this.rootElement.appendChild(ur.createButton(this.renderer,e)),this.renderer.xr.addEventListener("sessionstart",s=>{this.webXRActive=!0}),this.renderer.xr.addEventListener("sessionend",s=>{this.webXRActive=!1}),this.renderer.xr.enabled=!0,this.camera.position.copy(this.initialCameraPosition),this.camera.up.copy(this.cameraUp).normalize(),this.camera.lookAt(this.initialCameraLookAt))}setupControls(){if(this.useBuiltInControls&&this.webXRMode===je.None){this.usingExternalCamera?this.camera.isOrthographicCamera?this.orthographicControls=new It(this.camera,this.renderer.domElement):this.perspectiveControls=new It(this.camera,this.renderer.domElement):(this.perspectiveControls=new It(this.perspectiveCamera,this.renderer.domElement),this.orthographicControls=new It(this.orthographicCamera,this.renderer.domElement));for(let e of[this.orthographicControls,this.perspectiveControls])e&&(e.listenToKeyEvents(window),e.rotateSpeed=.5,e.maxPolarAngle=Math.PI*.75,e.minPolarAngle=.1,e.enableDamping=!0,e.dampingFactor=.05,e.target.copy(this.initialCameraLookAt),e.update());this.controls=this.camera.isOrthographicCamera?this.orthographicControls:this.perspectiveControls,this.controls.update()}}setupEventHandlers(){this.useBuiltInControls&&this.webXRMode===je.None&&(this.mouseMoveListener=this.onMouseMove.bind(this),this.renderer.domElement.addEventListener("pointermove",this.mouseMoveListener,!1),this.mouseDownListener=this.onMouseDown.bind(this),this.renderer.domElement.addEventListener("pointerdown",this.mouseDownListener,!1),this.mouseUpListener=this.onMouseUp.bind(this),this.renderer.domElement.addEventListener("pointerup",this.mouseUpListener,!1),this.keyDownListener=this.onKeyDown.bind(this),window.addEventListener("keydown",this.keyDownListener,!1))}removeEventHandlers(){this.useBuiltInControls&&(this.renderer.domElement.removeEventListener("pointermove",this.mouseMoveListener),this.mouseMoveListener=null,this.renderer.domElement.removeEventListener("pointerdown",this.mouseDownListener),this.mouseDownListener=null,this.renderer.domElement.removeEventListener("pointerup",this.mouseUpListener),this.mouseUpListener=null,window.removeEventListener("keydown",this.keyDownListener),this.keyDownListener=null)}setRenderMode(e){this.renderMode=e}setActiveSphericalHarmonicsDegrees(e){this.splatMesh.material.uniforms.sphericalHarmonicsDegree.value=e,this.splatMesh.material.uniformsNeedUpdate=!0}onSplatMeshChanged(e){this.onSplatMeshChangedCallback=e}onKeyDown=(function(){const e=new v,s=new J,t=new J;return function(n){switch(e.set(0,0,-1),e.transformDirection(this.camera.matrixWorld),s.makeRotationAxis(e,Math.PI/128),t.makeRotationAxis(e,-Math.PI/128),n.code){case"KeyG":this.focalAdjustment+=.02,this.forceRenderNextFrame();break;case"KeyF":this.focalAdjustment-=.02,this.forceRenderNextFrame();break;case"ArrowLeft":this.camera.up.transformDirection(s);break;case"ArrowRight":this.camera.up.transformDirection(t);break;case"KeyC":this.showMeshCursor=!this.showMeshCursor;break;case"KeyU":this.showControlPlane=!this.showControlPlane;break;case"KeyI":this.showInfo=!this.showInfo,this.showInfo?this.infoPanel.show():this.infoPanel.hide();break;case"KeyO":this.usingExternalCamera||this.setOrthographicMode(!this.camera.isOrthographicCamera);break;case"KeyP":this.usingExternalCamera||this.splatMesh.setPointCloudModeEnabled(!this.splatMesh.getPointCloudModeEnabled());break;case"Equal":this.usingExternalCamera||this.splatMesh.setSplatScale(this.splatMesh.getSplatScale()+.05);break;case"Minus":this.usingExternalCamera||this.splatMesh.setSplatScale(Math.max(this.splatMesh.getSplatScale()-.05,0));break}}})();onMouseMove(e){this.mousePosition.set(e.offsetX,e.offsetY)}onMouseDown(){this.mouseDownPosition.copy(this.mousePosition),this.mouseDownTime=We()}onMouseUp=(function(){const e=new N;return function(s){e.copy(this.mousePosition).sub(this.mouseDownPosition),We()-this.mouseDownTime<.5&&e.length()<2&&this.onMouseClick(s)}})();onMouseClick(e){this.mousePosition.set(e.offsetX,e.offsetY),this.checkForFocalPointChange()}checkForFocalPointChange=(function(){const e=new N,s=new v,t=[];return function(){if(!this.transitioningCameraTarget&&(this.getRenderDimensions(e),t.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,e),this.raycaster.intersectSplatMesh(this.splatMesh,t),t.length>0)){const o=t[0].origin;s.copy(o).sub(this.camera.position),s.length()>fr&&(this.previousCameraTarget.copy(this.controls.target),this.nextCameraTarget.copy(o),this.transitioningCameraTarget=!0,this.transitioningCameraTargetStartTime=We())}}})();getRenderDimensions(e){this.rootElement?(e.x=this.rootElement.offsetWidth,e.y=this.rootElement.offsetHeight):this.renderer.getSize(e)}setOrthographicMode(e){if(e===this.camera.isOrthographicCamera)return;const s=this.camera,t=e?this.orthographicCamera:this.perspectiveCamera;if(t.position.copy(s.position),t.up.copy(s.up),t.rotation.copy(s.rotation),t.quaternion.copy(s.quaternion),t.matrix.copy(s.matrix),this.camera=t,this.controls){const n=r=>{r.saveState(),r.reset()},o=this.controls,i=e?this.orthographicControls:this.perspectiveControls;n(i),n(o),i.target.copy(o.target),e?rt.setCameraZoomFromPosition(t,s,o):rt.setCameraPositionFromZoom(t,s,i),this.controls=i,this.camera.lookAt(this.controls.target)}}static setCameraPositionFromZoom=(function(){const e=new v;return function(s,t,n){const o=1/(t.zoom*.001);e.copy(n.target).sub(s.position).normalize().multiplyScalar(o).negate(),s.position.copy(n.target).add(e)}})();static setCameraZoomFromPosition=(function(){const e=new v;return function(s,t,n){const o=e.copy(n.target).sub(t.position).length();s.zoom=1/(o*.001)}})();updateSplatMesh=(function(){const e=new N;return function(){if(!this.splatMesh)return;if(this.splatMesh.getSplatCount()>0){this.splatMesh.updateVisibleRegionFadeDistance(this.sceneRevealMode),this.splatMesh.updateTransforms(),this.getRenderDimensions(e);const t=this.camera.projectionMatrix.elements[0]*.5*this.devicePixelRatio*e.x,n=this.camera.projectionMatrix.elements[5]*.5*this.devicePixelRatio*e.y,o=this.camera.isOrthographicCamera?1/this.devicePixelRatio:1,i=this.focalAdjustment*o,r=1/i;this.adjustForWebXRStereo(e),this.splatMesh.updateUniforms(e,t*i,n*i,this.camera.isOrthographicCamera,this.camera.zoom||1,r)}}})();adjustForWebXRStereo(e){if(this.camera&&this.webXRActive){const t=this.renderer.xr.getCamera().projectionMatrix.elements[0],n=this.camera.projectionMatrix.elements[0];e.x*=n/t}}isLoadingOrUnloading(){return Object.keys(this.splatSceneDownloadPromises).length>0||this.splatSceneDownloadAndBuildPromise!==null||this.splatSceneRemovalPromise!==null}isDisposingOrDisposed(){return this.disposing||this.disposed}addSplatSceneDownloadPromise(e){this.splatSceneDownloadPromises[e.id]=e}removeSplatSceneDownloadPromise(e){delete this.splatSceneDownloadPromises[e.id]}setSplatSceneDownloadAndBuildPromise(e){this.splatSceneDownloadAndBuildPromise=e}clearSplatSceneDownloadAndBuildPromise(){this.splatSceneDownloadAndBuildPromise=null}addSplatScene(e,s={}){if(this.isLoadingOrUnloading())throw new Error("Cannot add splat scene while another load or unload is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot add splat scene after dispose() is called.");s.progressiveLoad&&this.splatMesh.scenes&&this.splatMesh.scenes.length>0&&(console.log('addSplatScene(): "progressiveLoad" option ignore because there are multiple splat scenes'),s.progressiveLoad=!1);const t=s.format!==void 0&&s.format!==null?s.format:_s(e),n=rt.isProgressivelyLoadable(t)&&s.progressiveLoad,o=s.showLoadingUI!==void 0&&s.showLoadingUI!==null?s.showLoadingUI:!0;let i=null;o&&(this.loadingSpinner.removeAllTasks(),i=this.loadingSpinner.addTask("Downloading..."));const r=()=>{this.loadingProgressBar.hide(),this.loadingSpinner.removeAllTasks()},a=(p,A,C)=>{if(o)if(C===ue.Downloading)if(p==100)this.loadingSpinner.setMessageForTask(i,"Download complete!");else if(n)this.loadingSpinner.setMessageForTask(i,"Downloading splats...");else{const g=A?`: ${A}`:"...";this.loadingSpinner.setMessageForTask(i,`Downloading${g}`)}else C===ue.Processing&&this.loadingSpinner.setMessageForTask(i,"Processing splats...")};let l=!1,c=0;const d=(p,A)=>{o&&((p&&n||A&&!n)&&(this.loadingSpinner.removeTask(i),!A&&!l&&this.loadingProgressBar.show()),n&&(A?(l=!0,this.loadingProgressBar.hide()):this.loadingProgressBar.setProgress(c)))},u=(p,A,C)=>{c=p,a(p,A,C),s.onProgress&&s.onProgress(p,A,C)},h=(p,A,C)=>{!n&&s.onProgress&&s.onProgress(0,"0%",ue.Processing);const g={rotation:s.rotation||s.orientation,position:s.position,scale:s.scale,splatAlphaRemovalThreshold:s.splatAlphaRemovalThreshold};return this.addSplatBuffers([p],[g],C,A&&o,o,n,n).then(()=>{!n&&s.onProgress&&s.onProgress(100,"100%",ue.Processing),d(A,C)})};return(n?this.downloadAndBuildSingleSplatSceneProgressiveLoad.bind(this):this.downloadAndBuildSingleSplatSceneStandardLoad.bind(this))(e,t,s.splatAlphaRemovalThreshold,h.bind(this),u,r.bind(this),s.headers)}downloadAndBuildSingleSplatSceneStandardLoad(e,s,t,n,o,i,r){const a=this.downloadSplatSceneToSplatBuffer(e,t,o,!1,void 0,s,r),l=Ot(a.abortHandler);return a.then(c=>(this.removeSplatSceneDownloadPromise(a),n(c,!0,!0).then(()=>{l.resolve(),this.clearSplatSceneDownloadAndBuildPromise()}))).catch(c=>{i&&i(),this.clearSplatSceneDownloadAndBuildPromise(),this.removeSplatSceneDownloadPromise(a),l.reject(this.updateError(c,`Viewer::addSplatScene -> Could not load file ${e}`))}),this.addSplatSceneDownloadPromise(a),this.setSplatSceneDownloadAndBuildPromise(l.promise),l.promise}downloadAndBuildSingleSplatSceneProgressiveLoad(e,s,t,n,o,i,r){let a=0,l=!1;const c=[],d=()=>{if(c.length>0&&!l&&!this.isDisposingOrDisposed()){l=!0;const A=c.shift();n(A.splatBuffer,A.firstBuild,A.finalBuild).then(()=>{l=!1,A.firstBuild?f.resolve():A.finalBuild&&(p.resolve(),this.clearSplatSceneDownloadAndBuildPromise()),c.length>0&&ve(()=>d())})}},u=(A,C)=>{this.isDisposingOrDisposed()||(C||c.length===0||A.getSplatCount()>c[0].splatBuffer.getSplatCount())&&(c.push({splatBuffer:A,firstBuild:a===0,finalBuild:C}),a++,d())},h=this.downloadSplatSceneToSplatBuffer(e,t,o,!0,u,s,r),f=Ot(h.abortHandler),p=Ot();return this.addSplatSceneDownloadPromise(h),this.setSplatSceneDownloadAndBuildPromise(p.promise),h.then(()=>{this.removeSplatSceneDownloadPromise(h)}).catch(A=>{this.clearSplatSceneDownloadAndBuildPromise(),this.removeSplatSceneDownloadPromise(h);const C=this.updateError(A,"Viewer::addSplatScene -> Could not load one or more scenes");f.reject(C),i&&i(C)}),f.promise}addSplatScenes(e,s=!0,t=void 0){if(this.isLoadingOrUnloading())throw new Error("Cannot add splat scene while another load or unload is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot add splat scene after dispose() is called.");const n=e.length,o=[];let i;s&&(this.loadingSpinner.removeAllTasks(),i=this.loadingSpinner.addTask("Downloading..."));const r=(d,u,h,f)=>{o[d]=u;let p=0;for(let A=0;A<n;A++)p+=o[A]||0;p=p/n,h=`${p.toFixed(2)}%`,s&&f===ue.Downloading&&this.loadingSpinner.setMessageForTask(i,p==100?"Download complete!":`Downloading: ${h}`),t&&t(p,h,f)},a=[],l=[];for(let d=0;d<e.length;d++){const u=e[d],h=u.format!==void 0&&u.format!==null?u.format:_s(u.path),f=this.downloadSplatSceneToSplatBuffer(u.path,u.splatAlphaRemovalThreshold,r.bind(this,d),!1,void 0,h,u.headers);a.push(f),l.push(f.promise)}const c=new _e((d,u)=>{Promise.all(l).then(h=>{s&&this.loadingSpinner.removeTask(i),t&&t(0,"0%",ue.Processing),this.addSplatBuffers(h,e,!0,s,s,!1,!1).then(()=>{t&&t(100,"100%",ue.Processing),this.clearSplatSceneDownloadAndBuildPromise(),d()})}).catch(h=>{s&&this.loadingSpinner.removeTask(i),this.clearSplatSceneDownloadAndBuildPromise(),u(this.updateError(h,"Viewer::addSplatScenes -> Could not load one or more splat scenes."))}).finally(()=>{this.removeSplatSceneDownloadPromise(c)})},d=>{for(let u of a)u.abort(d)});return this.addSplatSceneDownloadPromise(c),this.setSplatSceneDownloadAndBuildPromise(c),c}downloadSplatSceneToSplatBuffer(e,s=1,t=void 0,n=!1,o=void 0,i,r){try{if(i===Te.Splat||i===Te.KSplat||i===Te.Ply){const a=n?!1:this.optimizeSplatData;if(i===Te.Splat)return is.loadFromURL(e,t,n,o,s,this.inMemoryCompressionLevel,a,r);if(i===Te.KSplat)return lt.loadFromURL(e,t,n,o,r);if(i===Te.Ply)return os.loadFromURL(e,t,n,o,s,this.inMemoryCompressionLevel,a,this.sphericalHarmonicsDegree,r)}else if(i===Te.Spz)return rs.loadFromURL(e,t,s,this.inMemoryCompressionLevel,this.optimizeSplatData,this.sphericalHarmonicsDegree,r)}catch(a){throw this.updateError(a,null)}throw new Error(`Viewer::downloadSplatSceneToSplatBuffer -> File format not supported: ${e}`)}static isProgressivelyLoadable(e){return e===Te.Splat||e===Te.KSplat||e===Te.Ply}addSplatBuffers=(function(){return function(e,s=[],t=!0,n=!0,o=!0,i=!1,r=!1,a=!0){if(this.isDisposingOrDisposed())return Promise.resolve();let l=null;const c=()=>{l!==null&&(this.loadingSpinner.removeTask(l),l=null)};return this.splatRenderReady=!1,new Promise(d=>{n&&(l=this.loadingSpinner.addTask("Processing splats...")),ve(()=>{if(this.isDisposingOrDisposed())d();else{const u=this.addSplatBuffersToMesh(e,s,t,o,i,a),h=this.splatMesh.getMaxSplatCount();this.sortWorker&&this.sortWorker.maxSplatCount!==h&&this.disposeSortWorker(),this.gpuAcceleratedSort||this.preSortMessages.push({centers:u.centers.buffer,sceneIndexes:u.sceneIndexes.buffer,range:{from:u.from,to:u.to,count:u.count}}),(!this.sortWorker&&h>0?this.setupSortWorker(this.splatMesh):Promise.resolve()).then(()=>{this.isDisposingOrDisposed()||this.runSplatSort(!0,!0).then(p=>{!this.sortWorker||!p?(this.splatRenderReady=!0,c(),d()):(r?this.splatRenderReady=!0:this.runAfterNextSort.push(()=>{this.splatRenderReady=!0}),this.runAfterNextSort.push(()=>{c(),d()}))})})}},!0)})}})();addSplatBuffersToMesh=(function(){let e;return function(s,t,n=!0,o=!1,i=!1,r=!0){if(this.isDisposingOrDisposed())return;let a=[],l=[];i||(a=this.splatMesh.scenes.map(h=>h.splatBuffer)||[],l=this.splatMesh.sceneOptions?this.splatMesh.sceneOptions.map(h=>h):[]),a.push(...s),l.push(...t),this.renderer&&this.splatMesh.setRenderer(this.renderer);const c=h=>{if(this.isDisposingOrDisposed())return;const f=this.splatMesh.getSplatCount();o&&f>=mr&&!h&&!e&&(this.loadingSpinner.setMinimized(!0,!0),e=this.loadingSpinner.addTask("Optimizing data structures..."))},d=h=>{this.isDisposingOrDisposed()||h&&e&&(this.loadingSpinner.removeTask(e),e=null)},u=this.splatMesh.build(a,l,!0,n,c,d,r);return n&&this.freeIntermediateSplatData&&this.splatMesh.freeIntermediateSplatData(),u}})();setupSortWorker(e){if(!this.isDisposingOrDisposed())return new Promise(s=>{const t=this.integerBasedSort?Int32Array:Float32Array,n=e.getSplatCount(),o=e.getMaxSplatCount();this.sortWorker=hr(o,this.sharedMemoryForWorkers,this.enableSIMDInSort,this.integerBasedSort,this.splatMesh.dynamicMode,this.splatSortDistanceMapPrecision),this.sortWorker.onmessage=i=>{if(i.data.sortDone){if(this.sortRunning=!1,this.sharedMemoryForWorkers)this.splatMesh.updateRenderIndexes(this.sortWorkerSortedIndexes,i.data.splatRenderCount);else{const r=new Uint32Array(i.data.sortedIndexes.buffer,0,i.data.splatRenderCount);this.splatMesh.updateRenderIndexes(r,i.data.splatRenderCount)}this.lastSplatSortCount=this.splatSortCount,this.lastSortTime=i.data.sortTime,this.sortPromiseResolver(),this.sortPromiseResolver=null,this.forceRenderNextFrame(),this.runAfterNextSort.length>0&&(this.runAfterNextSort.forEach(r=>{r()}),this.runAfterNextSort.length=0)}else if(i.data.sortCanceled)this.sortRunning=!1;else if(i.data.sortSetupPhase1Complete){this.logLevel>=$e.Info&&console.log("Sorting web worker WASM setup complete."),this.sharedMemoryForWorkers?(this.sortWorkerSortedIndexes=new Uint32Array(i.data.sortedIndexesBuffer,i.data.sortedIndexesOffset,o),this.sortWorkerIndexesToSort=new Uint32Array(i.data.indexesToSortBuffer,i.data.indexesToSortOffset,o),this.sortWorkerPrecomputedDistances=new t(i.data.precomputedDistancesBuffer,i.data.precomputedDistancesOffset,o),this.sortWorkerTransforms=new Float32Array(i.data.transformsBuffer,i.data.transformsOffset,Y.MaxScenes*16)):(this.sortWorkerIndexesToSort=new Uint32Array(o),this.sortWorkerPrecomputedDistances=new t(o),this.sortWorkerTransforms=new Float32Array(Y.MaxScenes*16));for(let r=0;r<n;r++)this.sortWorkerIndexesToSort[r]=r;if(this.sortWorker.maxSplatCount=o,this.logLevel>=$e.Info){console.log("Sorting web worker ready.");const r=this.splatMesh.getSplatDataTextures(),a=r.covariances.size,l=r.centerColors.size;console.log("Covariances texture size: "+a.x+" x "+a.y),console.log("Centers/colors texture size: "+l.x+" x "+l.y)}s()}}})}updateError(e,s){return e instanceof en?e:e instanceof wt?new Error("File type or server does not support progressive loading."):s?new Error(s):e}disposeSortWorker(){this.sortWorker&&this.sortWorker.terminate(),this.sortWorker=null,this.sortPromise=null,this.sortPromiseResolver&&(this.sortPromiseResolver(),this.sortPromiseResolver=null),this.preSortMessages=[],this.sortRunning=!1}removeSplatScene(e,s=!0){return this.removeSplatScenes([e],s)}removeSplatScenes(e,s=!0){if(this.isLoadingOrUnloading())throw new Error("Cannot remove splat scene while another load or unload is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot remove splat scene after dispose() is called.");let t;return this.splatSceneRemovalPromise=new Promise((n,o)=>{let i;s&&(this.loadingSpinner.removeAllTasks(),this.loadingSpinner.show(),i=this.loadingSpinner.addTask("Removing splat scene..."));const r=()=>{s&&(this.loadingSpinner.hide(),this.loadingSpinner.removeTask(i))},a=c=>{r(),this.splatSceneRemovalPromise=null,c?o(c):n()},l=()=>this.isDisposingOrDisposed()?(a(),!0):!1;t=this.sortPromise||Promise.resolve(),t.then(()=>{if(l())return;const c=[],d=[],u=[];for(let h=0;h<this.splatMesh.scenes.length;h++){let f=!1;for(let p of e)if(p===h){f=!0;break}if(!f){const p=this.splatMesh.scenes[h];c.push(p.splatBuffer),d.push(this.splatMesh.sceneOptions[h]),u.push({position:p.position.clone(),quaternion:p.quaternion.clone(),scale:p.scale.clone()})}}this.disposeSortWorker(),this.splatMesh.dispose(),this.sceneRevealMode=ht.Instant,this.createSplatMesh(),this.addSplatBuffers(c,d,!0,!1,!0).then(()=>{l()||(r(),this.splatMesh.scenes.forEach((h,f)=>{h.position.copy(u[f].position),h.quaternion.copy(u[f].quaternion),h.scale.copy(u[f].scale)}),this.splatMesh.updateTransforms(),this.splatRenderReady=!1,this.runSplatSort(!0).then(()=>{if(l()){this.splatRenderReady=!0;return}t=this.sortPromise||Promise.resolve(),t.then(()=>{this.splatRenderReady=!0,a()})}))}).catch(h=>{a(h)})})}),this.splatSceneRemovalPromise}start(){if(this.selfDrivenMode)this.webXRMode?this.renderer.setAnimationLoop(this.selfDrivenUpdateFunc):this.requestFrameId=requestAnimationFrame(this.selfDrivenUpdateFunc),this.selfDrivenModeRunning=!0;else throw new Error("Cannot start viewer unless it is in self driven mode.")}stop(){this.selfDrivenMode&&this.selfDrivenModeRunning&&(this.webXRMode?this.renderer.setAnimationLoop(null):cancelAnimationFrame(this.requestFrameId),this.selfDrivenModeRunning=!1)}async dispose(){if(this.isDisposingOrDisposed())return this.disposePromise;let e=[],s=[];for(let t in this.splatSceneDownloadPromises)if(this.splatSceneDownloadPromises.hasOwnProperty(t)){const n=this.splatSceneDownloadPromises[t];s.push(n),e.push(n.promise)}return this.sortPromise&&e.push(this.sortPromise),this.disposing=!0,this.disposePromise=Promise.all(e).finally(()=>{this.stop(),this.orthographicControls&&(this.orthographicControls.dispose(),this.orthographicControls=null),this.perspectiveControls&&(this.perspectiveControls.dispose(),this.perspectiveControls=null),this.controls=null,this.splatMesh&&(this.splatMesh.dispose(),this.splatMesh=null),this.sceneHelper&&(this.sceneHelper.dispose(),this.sceneHelper=null),this.resizeObserver&&(this.resizeObserver.unobserve(this.rootElement),this.resizeObserver=null),this.disposeSortWorker(),this.removeEventHandlers(),this.loadingSpinner.removeAllTasks(),this.loadingSpinner.setContainer(null),this.loadingProgressBar.hide(),this.loadingProgressBar.setContainer(null),this.infoPanel.setContainer(null),this.camera=null,this.threeScene=null,this.splatRenderReady=!1,this.initialized=!1,this.renderer&&(this.usingExternalRenderer||(this.rootElement.removeChild(this.renderer.domElement),this.renderer.dispose()),this.renderer=null),this.usingExternalRenderer||document.body.removeChild(this.rootElement),this.sortWorkerSortedIndexes=null,this.sortWorkerIndexesToSort=null,this.sortWorkerPrecomputedDistances=null,this.sortWorkerTransforms=null,this.disposed=!0,this.disposing=!1,this.disposePromise=null}),s.forEach(t=>{t.abort("Scene disposed")}),this.disposePromise}selfDrivenUpdate(){this.selfDrivenMode&&!this.webXRMode&&(this.requestFrameId=requestAnimationFrame(this.selfDrivenUpdateFunc)),this.update(),this.shouldRender()?(this.render(),this.consecutiveRenderFrames++):this.consecutiveRenderFrames=0,this.renderNextFrame=!1}forceRenderNextFrame(){this.renderNextFrame=!0}shouldRender=(function(){let e=0;const s=new v,t=new ge,n=1e-4;return function(){if(!this.initialized||!this.splatRenderReady||this.isDisposingOrDisposed())return!1;let o=!1,i=!1;if(this.camera){const r=this.camera.position,a=this.camera.quaternion;i=Math.abs(r.x-s.x)>n||Math.abs(r.y-s.y)>n||Math.abs(r.z-s.z)>n||Math.abs(a.x-t.x)>n||Math.abs(a.y-t.y)>n||Math.abs(a.z-t.z)>n||Math.abs(a.w-t.w)>n}return o=this.renderMode!==Nt.Never&&(e===0||this.splatMesh.visibleRegionChanging||i||this.renderMode===Nt.Always||this.dynamicMode===!0||this.renderNextFrame),this.camera&&(s.copy(this.camera.position),t.copy(this.camera.quaternion)),e++,o}})();render=(function(){return function(){if(!this.initialized||!this.splatRenderReady||this.isDisposingOrDisposed())return;const e=t=>{for(let n of t.children)if(n.visible)return!0;return!1},s=this.renderer.autoClear;e(this.threeScene)&&(this.renderer.render(this.threeScene,this.camera),this.renderer.autoClear=!1),this.renderer.render(this.splatMesh,this.camera),this.renderer.autoClear=!1,this.sceneHelper.getFocusMarkerOpacity()>0&&this.renderer.render(this.sceneHelper.focusMarker,this.camera),this.showControlPlane&&this.renderer.render(this.sceneHelper.controlPlane,this.camera),this.renderer.autoClear=s}})();update(e,s){this.dropInMode&&this.updateForDropInMode(e,s),!(!this.initialized||!this.splatRenderReady||this.isDisposingOrDisposed())&&(this.controls&&(this.controls.update(),this.camera.isOrthographicCamera&&!this.usingExternalCamera&&rt.setCameraPositionFromZoom(this.camera,this.camera,this.controls)),this.runSplatSort(),this.updateForRendererSizeChanges(),this.updateSplatMesh(),this.updateMeshCursor(),this.updateFPS(),this.timingSensitiveUpdates(),this.updateInfoPanel(),this.updateControlPlane())}updateForDropInMode(e,s){this.renderer=e,this.splatMesh&&this.splatMesh.setRenderer(this.renderer),this.camera=s,this.controls&&(this.controls.object=s),this.init()}updateFPS=(function(){let e=We(),s=0;return function(){if(this.consecutiveRenderFrames>Cr){const t=We();t-e>=1?(this.currentFPS=s,s=0,e=t):s++}else this.currentFPS=null}})();updateForRendererSizeChanges=(function(){const e=new N,s=new N;let t;return function(){this.usingExternalCamera||(this.renderer.getSize(s),(t===void 0||t!==this.camera.isOrthographicCamera||s.x!==e.x||s.y!==e.y)&&(this.camera.isOrthographicCamera?(this.camera.left=-s.x/2,this.camera.right=s.x/2,this.camera.top=s.y/2,this.camera.bottom=-s.y/2):this.camera.aspect=s.x/s.y,this.camera.updateProjectionMatrix(),e.copy(s),t=this.camera.isOrthographicCamera))}})();timingSensitiveUpdates=(function(){let e;return function(){const s=We();e||(e=s);const t=s-e;this.updateCameraTransition(s),this.updateFocusMarker(t),e=s}})();updateCameraTransition=(function(){let e=new v,s=new v,t=new v;return function(n){if(this.transitioningCameraTarget){s.copy(this.previousCameraTarget).sub(this.camera.position).normalize(),t.copy(this.nextCameraTarget).sub(this.camera.position).normalize();const o=Math.acos(s.dot(t)),r=(o/(Math.PI/3)*.65+.3)/o*(n-this.transitioningCameraTargetStartTime);e.copy(this.previousCameraTarget).lerp(this.nextCameraTarget,r),this.camera.lookAt(e),this.controls.target.copy(e),r>=1&&(this.transitioningCameraTarget=!1)}}})();updateFocusMarker=(function(){const e=new N;let s=!1;return function(t){if(this.getRenderDimensions(e),this.transitioningCameraTarget){this.sceneHelper.setFocusMarkerVisibility(!0);const n=Math.max(this.sceneHelper.getFocusMarkerOpacity(),0);let o=Math.min(n+Ar*t,1);this.sceneHelper.setFocusMarkerOpacity(o),this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,e),s=!0,this.forceRenderNextFrame()}else{let n;if(s?n=1:n=Math.min(this.sceneHelper.getFocusMarkerOpacity(),1),n>0){this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,e);let o=Math.max(n-gr*t,0);this.sceneHelper.setFocusMarkerOpacity(o),o===0&&this.sceneHelper.setFocusMarkerVisibility(!1)}n>0&&this.forceRenderNextFrame(),s=!1}}})();updateMeshCursor=(function(){const e=[],s=new N;return function(){this.showMeshCursor?(this.forceRenderNextFrame(),this.getRenderDimensions(s),e.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,s),this.raycaster.intersectSplatMesh(this.splatMesh,e),e.length>0?(this.sceneHelper.setMeshCursorVisibility(!0),this.sceneHelper.positionAndOrientMeshCursor(e[0].origin,this.camera)):this.sceneHelper.setMeshCursorVisibility(!1)):(this.sceneHelper.getMeschCursorVisibility()&&this.forceRenderNextFrame(),this.sceneHelper.setMeshCursorVisibility(!1))}})();updateInfoPanel=(function(){const e=new N;return function(){if(!this.showInfo)return;const s=this.splatMesh.getSplatCount();this.getRenderDimensions(e);const t=this.controls?this.controls.target:null,n=this.showMeshCursor?this.sceneHelper.meshCursor.position:null,o=s>0?this.splatRenderCount/s*100:0;this.infoPanel.update(e,this.camera.position,t,this.camera.up,this.camera.isOrthographicCamera,n,this.currentFPS||"N/A",s,this.splatRenderCount,o,this.lastSortTime,this.focalAdjustment,this.splatMesh.getSplatScale(),this.splatMesh.getPointCloudModeEnabled())}})();updateControlPlane(){this.showControlPlane?(this.sceneHelper.setControlPlaneVisibility(!0),this.sceneHelper.positionAndOrientControlPlane(this.controls.target,this.camera.up)):this.sceneHelper.setControlPlaneVisibility(!1)}runSplatSort=(function(){const e=new J,s=[],t=new v(0,0,-1),n=new v(0,0,-1),o=new v,i=new v,r=[],a=[{angleThreshold:.55,sortFractions:[.125,.33333,.75]},{angleThreshold:.65,sortFractions:[.33333,.66667]},{angleThreshold:.8,sortFractions:[.5]}];return function(l=!1,c=!1){if(!this.initialized)return Promise.resolve(!1);if(this.sortRunning)return Promise.resolve(!0);if(this.splatMesh.getSplatCount()<=0)return this.splatRenderCount=0,Promise.resolve(!1);let d=0,u=0,h=!1,f=!1;if(n.set(0,0,-1).applyQuaternion(this.camera.quaternion),d=n.dot(t),u=i.copy(this.camera.position).sub(o).length(),!l&&!this.splatMesh.dynamicMode&&r.length===0&&(d<=.99&&(h=!0),u>=1&&(f=!0),!h&&!f))return Promise.resolve(!1);this.sortRunning=!0;let{splatRenderCount:p,shouldSortAll:A}=this.gatherSceneNodesForSort();A=A||c,this.splatRenderCount=p,e.copy(this.camera.matrixWorld).invert();const C=this.perspectiveCamera||this.camera;e.premultiply(C.projectionMatrix),this.splatMesh.dynamicMode||e.multiply(this.splatMesh.matrixWorld);let g=Promise.resolve(!0);return this.gpuAcceleratedSort&&(r.length<=1||r.length%2===0)&&(g=this.splatMesh.computeDistancesOnGPU(e,this.sortWorkerPrecomputedDistances)),g.then(()=>{if(r.length===0)if(this.splatMesh.dynamicMode||A)r.push(this.splatRenderCount);else{for(let y of a)if(d<y.angleThreshold){for(let E of y.sortFractions)r.push(Math.floor(this.splatRenderCount*E));break}r.push(this.splatRenderCount)}let x=Math.min(r.shift(),this.splatRenderCount);this.splatSortCount=x,s[0]=this.camera.position.x,s[1]=this.camera.position.y,s[2]=this.camera.position.z;const B={modelViewProj:e.elements,cameraPosition:s,splatRenderCount:this.splatRenderCount,splatSortCount:x,usePrecomputedDistances:this.gpuAcceleratedSort};return this.splatMesh.dynamicMode&&this.splatMesh.fillTransformsArray(this.sortWorkerTransforms),this.sharedMemoryForWorkers||(B.indexesToSort=this.sortWorkerIndexesToSort,B.transforms=this.sortWorkerTransforms,this.gpuAcceleratedSort&&(B.precomputedDistances=this.sortWorkerPrecomputedDistances)),this.sortPromise=new Promise(y=>{this.sortPromiseResolver=y}),this.preSortMessages.length>0&&(this.preSortMessages.forEach(y=>{this.sortWorker.postMessage(y)}),this.preSortMessages=[]),this.sortWorker.postMessage({sort:B}),r.length===0&&(o.copy(this.camera.position),t.copy(n)),!0}),g}})();gatherSceneNodesForSort=(function(){const e=[];let s=null;const t=new v,n=new v,o=new v,i=new J,r=new J,a=new J,l=new v,c=new v(0,0,-1),d=new v,u=h=>d.copy(h.max).sub(h.min).length();return function(h=!1){this.getRenderDimensions(l);const f=l.y/2/Math.tan(this.camera.fov/2*Zs.DEG2RAD),p=Math.atan(l.x/2/f),A=Math.atan(l.y/2/f),C=Math.cos(p),g=Math.cos(A),x=this.splatMesh.getSplatTree();if(x){r.copy(this.camera.matrixWorld).invert(),this.splatMesh.dynamicMode||r.multiply(this.splatMesh.matrixWorld);let B=0,y=0;for(let S=0;S<x.subTrees.length;S++){const w=x.subTrees[S];i.copy(r),this.splatMesh.dynamicMode&&(this.splatMesh.getSceneTransform(S,a),i.multiply(a));const F=w.nodesWithIndexes.length;for(let b=0;b<F;b++){const D=w.nodesWithIndexes[b];if(!D.data||!D.data.indexes||D.data.indexes.length===0)continue;o.copy(D.center).applyMatrix4(i);const M=o.length();o.normalize(),t.copy(o).setX(0).normalize(),n.copy(o).setY(0).normalize();const L=c.dot(n),R=c.dot(t),O=u(D),k=R<g-.6,U=L<C-.6;!h&&(U||k)&&M>O||(y+=D.data.indexes.length,e[B]=D,D.data.distanceToNode=M,B++)}}e.length=B,e.sort((S,w)=>S.data.distanceToNode<w.data.distanceToNode?-1:1);let E=y*Y.BytesPerInt;for(let S=0;S<B;S++){const w=e[S],F=w.data.indexes.length,b=F*Y.BytesPerInt;new Uint32Array(this.sortWorkerIndexesToSort.buffer,E-b,F).set(w.data.indexes),E-=b}return{splatRenderCount:y,shouldSortAll:!1}}else{const B=this.splatMesh.getSplatCount();if(!s||s.length!==B){s=new Uint32Array(B);for(let y=0;y<B;y++)s[y]=y}return this.sortWorkerIndexesToSort.set(s),{splatRenderCount:B,shouldSortAll:!0}}}})();getSplatMesh(){return this.splatMesh}getSplatScene(e){return this.splatMesh.getScene(e)}getSceneCount(){return this.splatMesh.getSceneCount()}isMobile(){return navigator.userAgent.includes("Mobi")}}export{rt as V};
//# sourceMappingURL=gaussian-splats-DQZQiU8n.js.map
